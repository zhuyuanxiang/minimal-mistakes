自然语言处理综论
==============

导论
----

会话代理（conversational agents）或者对话系统（dialogue
systems）的组成部分：语言输入和语言输出。

语言输入：

- 自动语音识别（automatic speech recognition）

- 自然语言理解（natural language understanding）

语言输出：

- 自然语言生成（natural language generation）

- 语音合成（speech synthesis）

推理（inference）：对于需要抽取嵌入到网页的其他文本中的信息才能回答的那些更加复杂的问题，需要根据已经知道的事实推出结论，或者从多重的信息源或网页中对信息进行综合或摘取。

自然语言理解系统：拼写歧正、语法检查

### 语音与语言处理中的知识

语音学（phonetics）：单词是怎样发出音来而成为声音序列的。

音系学（phonology）：每一个声音是怎样在语音学上实现的。

形态学：关于词的有意义的组成成分的知识

句法学：关于词与词之间结构关系的知识。

语义学：关于意义的知识

- 词汇语义学（lexical semantics）：单词的意义

- 组合语义学（copositional semantics）：单词组合的意义

语用学（pragmatic）或对话（dialogue）：关于意义与说话人的目的和意图之间的关系的知识

话语学：关于比一个单独的更大的语言单位的知识。

### 歧义

消解（resolve）或者排歧（disambiguation）的模型与算法。

词汇排歧（lexical disambiguation）：

- 词类标注（parts-of-speech tagging）

- 词义排歧（word sense disambiguation）

句法排歧（syntactic disambiguation），也叫语法排歧。

- 概率剖析（probabilistic parsing）

言语行为解释（speech act interpretation）

### 模型和算法

模型：

- 状态机器（state machine），就是形式模型。形式模型包括：状态、状态之间的转移以及输入表示等等。

  - 确定的有限状态自动机（deterministic finite-state automata，DFSA）

  - 非确定的有限状态自动机（non-deterministic finite-state automata，NFSA）

  - 有限状态转录机（finite-state transducers，FST）

- 形式规则系统（formal rule system）

  - 正则语法（regular grammars）

  - 正则关系（regular relations）

  - 上下文无关语法（context-free grammars）

  - 特征增益语法（feature-augmented grammars）

- 基于逻辑（logic）的模型

  - 一阶逻辑（first order logic），即谓词演算（predicate）

  - λ运算（lambda-calculus）

  - 特征结构（feature structure）

  - 语义基元（semantic primitives）

- 概率模型（probabilistic models）

  - 加权自动机（weighted automaton）

  - 隐马尔可夫模型（Hidden Markov Models，HMM）

- 向量空间模型（vector-space models）

算法：

- 动态规划（dynamic programming）算法的状态空间搜索（state space search）

  - 深度优先搜索（depth-first search）

  - 最佳优先搜索算法（best-first search）

  - A\*搜索算法（A\* search）（Ref：Ch10）

- 分类器（classifiers）和序列模型（sequence models）

  - 分类器把一个单独的客体指派到一个单独的类别中

.  - 决策树（decision trees）

.  - 支持向量机（support vector machines）

.  - 高斯混合矩阵（Gaussian mixture models）

.  - 逻辑回归（logistic regression）

  - 序列模型对于一个客体序列进行分类，并将它指派到一个类别序列中

- 期望最大化算法（Expecctation-Maximization，EM）

- 统计技术

  - 交叉验证（cross-validation）

### 语言、思维和理解

图灵测试（Turing test）

### 学科现状与近期发展

### 语音和语言处理简史

语言学中的计算语言学（computational linguistics）

计算机科学中的自然语言处理（natural language processing）

电子工程中的语音识别（speech recognition）

心理学中的计算机心理语言学（computational psycholinguistics）

### 小结

- 理解语音和语言处理

- 语音和语言处理技术与音系学、语音学、形态学、句法学、语义学、语用学和话语分析等不同平面上的语言知识的形式模型和形式表示方法存在着依赖关系。使用包括状态机、形式规则系统、逻辑等在内的形式模型以及概率模型。

- 语音和语言处理的基础是计算机科学、语言学、数学、电子工程和心理学。

- 语言和思维之间的密切联系使语音和语言处理技术成为了机器智能的一部分。

- 语音和语言处理的应用已经越来越丰富多彩。

1. 词汇处理

正则表达式 与 自动机
--------------------

正则表达式（regular expression）：描述文本序列的标准记录方式。

### 正则表达式

正则表达式的搜索需要试图搜索的模式（pattern）和被搜索的文本语料库（corpus）。

#### 基本的正则表达式模式

正则表达式是区分大小写的。

内部有括号的字符符号串表示所匹配的字符是析取（disjunction）的。

- 连字符“-”：表示在某一范围内的任何字符。

- 脱字符“\^”：如果是方括号内使用，表示否定后续的模式，即不出现某些字符；如果在方括号外使用，只表示字符本身。

- 通配符（wildcard）：点号“.”。表示任何与单个字符（回车符除外）相匹配的字符。点号常常与星号共用。

- 计数符：

  - 问号“?”：表示前面一个字符存在或者不存在。

  - 星号“\*”：称为“Kleene \*”，其直接前面的字符或正则表达式出现零次或者多次。

  - 加号“+”：称为“Kleene +”，其直接前面的字符或正则表达式出现一次或者多次。

  - 大括号“{m,n}”：表示前面的字符至少出现 m 次，至多出现 n 次。

- 锚号（anchors）：把正则表达式锚在符号串中某个特定位置的特殊字符。

  - 脱字符“\^”：与行的开始相匹配；

  - 美元符“\$”：与行的结束相匹配。

  - “\\b”：表示词界；

  - “\\B”：表示非词界。

#### 正则表达式的基本算符

析取符（pipe symbol）“\|”：析取算符（disjunction operator）。

圆括号“()”：表示优先关系。

算符优先层级（operator precedence hierarchy）：圆括号＞计数符＞序列与锚＞析取符

贪心模式：正则表达式尽可能与最长的符号串匹配。

#### 正则表达式的简单例子和复杂例子

例子中的错误：

- 正面错误（false positives）：错误地匹配的字符串

- 负面错误（false negatives）：错误地遗漏的字符串

增加准确率（accuracy）：把正面错误减少到最低限度。

增加覆盖率（coverage）：把负责错误减少到最低限度。

#### 正则表达式的高级算符

高级算符可以用简单算符来表达，高级算符可以简化表达式的内容，更加方便阅读和理解。

- \\d = [0-9]：任何数字字符

- \\D = [\^0-9]：任何非数字字符

- \\w = [a-zA-Z0-9_]：任何字母字符、数字字符或者空白字符

- \\W = [\^\\w]：一个非字母字符、数字字符或者空白字符

- \\s = [ \\r \\t \\n \\f]：空白区域（空白字符、制表字符、换行字符、回车字符）

- \\S = [\^\\s]：非空白区域

#### 正则表达式的实际操作

替换（substitution）

使用数字算符可以参照前面的模式。

数字算符使用数字存储器保存前面的模式，这些数字存储器称为寄存器（registers）。

### 有限状态自动机（FSA）

正则表达式：是一种用于文本搜索的元语言。是描述有限状态自动机（Finite-State
Automaton，FSA）的一种方法。是刻画正则语言（regular language）的一种方法。

正则语言是形式语言中的一种。正则语言可以使用正则表达式、有限状态自动机和正则语法（regular
grammar）进行描述，即三者是等价的。

FSA 是书中计算工作的理论基础，任何析正则表达式都可以使用有限状态自动机来实现 。

#### FSA 的表示方式

自动机（automaton），也叫有限自动机、有限状态自动机），能够识别符号串的集合。

- 图表示：结点表示状态，弧表示转移；

- 状态转移表（state-transition table）表示。

自动机需要 5 个参数实现形式化定义：

- 状态的有限集合

- 有限的输入符号字母表

- 初始状态

- 终极状态集合

- 状态之间的转移函数或者转移矩阵

#### FSA 中的形式语言

形式语言（formal
language）：是一个模型，能够而且只能够生成或者识别某一形式语言的符号串，这种形式语言的符号串需要满足形式语言的定义的要求。

形式语言是符号串的集合，而每一个符号串由字母表（alphabet）的有限的符号的集合组合而成。基于形式语言定义的自动机可以在封闭的形式中表示无限的集合。

生成语法（generative
grammar）：表示形式语言的语法，即自动机定义的能够生成一切可能的符号串的语言。

#### 非确定的 FSA（NFSA）

非确定的有限自动机（Non-deterministic
FSA，NFSA），也可以称之为概率的有限自动机（Probabilistic
FSA，PFSA），相对应的自动机也可以称之为确定的有限自动机。

NFSA 或 PFSA 存在概率转移（ε- 转移，ε-transition）。

#### NFSA 接收符号串

三种非确定问题的解决方案（solution to the problem of non-determinism）：

- 回退（backup）：在选择点做记号，记录位置和状态，当遇到错误的选择时可以回退到选择点，从而试探其他的路径

  - 在每个选择点上，需要记住所有不同的选择

  - 对于不同的选择，需要存储足够的信息

  - 结点与位置的结合体称为识别算法的搜索状态（search-state）。

  - 自动机的状态称为结点（node）或者机器状态（machine-state）。

- 前瞻（look-ahead）：在输入中向前看，预测性地判断应该选择哪条路径

- 并行（parallelism）：在选择点上并行探查每条不同的路径。

#### FSA 识别就是搜索

状态空间搜索（state-space
search）算法：系统地探索自动机中所有可能的路径，从而正确地识别正则语言中的符号串。

- 深度优先搜索（depth-first search）策略，即后进先出（Last In First
.  Out，LIFO）策略。当状态空间是无限的时候，搜索可能永远无法停止。

- 广度优先搜索（breadth-first search）策略，即先进先出（First In First
.  Out，FIFO）策略

- 规模较大的问题，更加复杂的搜索技术：动态规划（dynamic
.  programming）（Ref：Ch13）和 A\*搜索算法（Ref：Ch10）。

#### DFSA 与 NFSA 之间的关系

NFSA 与 DFSA 是完全等价的。

### 正则语言与有限状态自动机

正则语言的形式化定义。

正则语言的运算。

正则表达式与自动机的等价转换。

### 小结

- 正则表达式语言是模式匹配的有力工具。

- 正则表达式的基本运算包括符号的毗连、符号的析取（[]，\|，.）、记数符（\*，+，{m,n}）、锚号（\^，\$）和前于运算符（(，)）。

- 正则表达式等价有限状态自动机（FSA）。

- 存储器（\\1 和 ()）是一种高级运算，经常作为正则表达式的一部分，但是不能实现为有限自动机。

- 自动机把形式语言隐含地定义为在任何的词汇（符号集）中自动机所接收的符号串的集合。

- 确定的自动机（DFSA）的行为完全由它的状态决定。

- 非确定的自动机（NFSA）的行为有时必须在多条路径之间进行选择。

- 任何一个 NFSA 都可以转换成为 DFSA。

- NFSA 的进程表中搜索下一个状态的顺序决定了搜索策略：

  - 深度优先或者后进先出（LIFO）策略相当于把进程表看成堆栈；

  - 广度优先或者先进先出（FIFO）策略相当于把进程表看成队列。

- 任何的正则表达式都可以自动地编译为 NFSA，即可以自动地编译为 DFSA。

词 与 转录机
------------

正词法规则（orthographic rules）

形态规则（morphological rules）

形态剖析（morphological parsing）：把单词剖析为多个词素

剖析产生的结果可以是形态结构、句法结构、语义结构或者话语结构

剖析产生的形式可以是符号串、树或者网络

词干还原（stemming）、词目还原（lemmatization）、词例还原（tokenization）或者单词切分（word
segmentation）

计算两个单词在正记法上的相似度：

形态剖析计算相似度；最小编辑距离计算相似度。

### 英语形态学概观

形态学：是研究语素（小的意义单位）构成词的方法。

语素（morpheme）：是语言中负荷意义最小的单位。分为词干（stem）和词缀（affix）。

词缀包括：

- 前缀（prefix）：位于词干之前

- 后缀（suffix）：紧接词干之后

- 中缀（infix）：插入到词干中间

- 位缀（circumfix）：同时处于词干的前面和后面

语素构成单词的四种方法：

- 屈折（inflection）：把词干和一个表示语法的语素结合起来，所形成的单词一般与原来的词干属于同一个词类，还会产生一些如“一致关系”类的语法功能。

- 派生（derivation）：把词干和一个表示语法的语素结合起来，所形成的单词一般属于不同的词类，产生的新意义经常难于精确地预测

- 合成（compounding）：把多个词干结合在一起

- 附着（cliticization）：把一个单词与一个附着成分（clitic）结合起来。附着成分也是一个语素，它的句法作用像一个形式简化了的单词，按照音系学的规则或者正词法的规则附着在其他单词上。

#### 屈折形态学（inflectional morphology）

英语的屈折系统相对简单：只有名词、动词和部分形容词有屈折变化，可能的屈折词缀的数目也相对较少。屈折的能产性（productive）比较高。

英语名词的屈折变化：

- 复数（plural）

- 领属（possessive）

英语动词分类：

- 主要动词（main verbs）：eat, sleep, impeach

- 情态动词（modal verbs）：can, will, should

- 基础动词（primary verbs）：be, have, do

英语动词的屈折变化：

- 规则的屈折动词：

- 不规则的屈折动词：

#### 派生形态学（derivational morphology）

英语的派生系统相对复杂：通过对动词和形容词的变化产生名词，即名词化（nominalization）。派生的能产性比较低。

#### 附着（cliticization）

附着成分是处于词缀和单词之间的语言单位。位于单词前面的附着成分称为前附着成分（proclitics），跟在单词后面的附着成分称为后附着成分（enclitics）。

附着成分的音系学功能相当于词缀，一般比较短，也没有重读。

附着成分的句法功能更像一个单词，作用经常相当于代词、冠词、连接词或者动词。

#### 非毗连形态学

毗连形态学（concatenative morphology）：单词是由彼此毗连的语素构成的符号串。

非毗连形态学（non-concatenative morphology），也称为模板形态学（template
morphology）或者词根与模式形态学（root-and-pattern morphology）。

#### 一致关系（agreement）

数的一致，性的一致。

### 有限状态形态剖析

形态剖析器：

- 词表（lexicon）：词干和词缀表以及它们的基本信息

- 形态顺序规则（morphotactics）：关于形态顺序的模型，用于解释在一个词内，语素与语素之间的联系规则。

- 正词法规则（orthographic rules）：即拼写规则（spelling
.  rules）。当两个语素结合时，拼写变化的规则。

### 有限状态词表的建造

计算机词表的构造：

- 列出语言中的每个词干和词缀

- 表示出形态顺序规则，即词干和词缀的结合规则

  - 基于有限状态自动机为形态顺序规则建模

形态识别（morphological
recognition）问题：使用 FSA 判断由字母构成的输入符号串是否合法。

### 有限状态转录机（FST）

有限状态转录机（Finite-State
Transducer，FST）：用来进行两个层之间的映射的自动机，即可以进行两个符号集合之间的映射的有限自动机。

FST 的用途：

- 作为识别器（recognizer）：取一对符号串 S1 和 S2 作为输入和输出，如果 S1 作为输入得到输出是 S2，或者 S2 作为输入得到输出是 S1，则识别成功；否则识别失败。

- 作为生成器（generator）：如果 FST 能够输出一对符号串 S1 和 S2，则输出成功并同时输出这对符号串，否则输出失败。

- 作为翻译器（translator）：FST 输入符号串 S1，输出符号串 S2

- 作为关联器（relater）：计算机符号串的两个集合之间的关系

FST 需要 7 个参数定义：

- 状态的有限集合 N

- 对应于输入字母表中的符号的有限集合

- 对应于输出字母表中的符号的有限集合

- 初始符号

- 终极状态的集合

- 转换函数或者状态之间的转换矩阵

- 输出函数。对应于每一个状态和输入，给出可能的输出符号串的集合。

FSA 与正则语言同构（isomorphic），FST 与正则关系（regular relation）同构。

正则关系是符号串偶对的集合，作为符号串集合的正则语言的自然扩充。

#### 定序转录机和确定性

定序转录机（sequential transducer）：是转录机的一个次类，输入是确定的。

后继转录机（subsequential transducer）是定序转录机的泛化。

p- 后继转录机（p-subsequential transducer）：是后继转录机的泛化。

### 用于形态剖析的有限状态转录机

有限状态形态学（finite-state
morphology）的范式（paradigm），把一个单词表示为词汇层（lexical
level）和表层（surface level）之间的对应。

- 词汇层：表示组成该词的语素之间的毗连关系

- 表层：表示该词实际拼写的字母之间的毗连关系。

### 转录机和正词法规则

使用正词法规则来处理英语中在语素边界发生拼写变化的问题。

正词法规则可以在转录机上实现。

### 结合有限状态转录机的词表与规则

把转录机的词表和规则结合起来进行剖析和生成。

双层形态学结构，即能用于剖析，也能用于生成。

词表转录机把表示词干和形态特征的词汇层面映射于表示语素简单毗连的中间层面。

若干个正词法转录机并行地运行各种不同的拼写规则。

有限状态转录机从词汇带子生成表层带子时，或者从表层带子剖析词汇带子时，都可以使用带有同样状态序列的同样的层叠式转录机。

剖析比生成要复杂一些，因为在剖析中存在歧义的问题，而排歧需要某些外部的证据。

运行层叠式转录机时，可以通过组合（composing）和交合（intersecting）转录机的方式使之更加有效。

### Porter 词干处理器（不使用词表）

形态剖析的标准算法：使用词表加规则的方法来建立转录机。缺点是需要大规模的联机词表。

Porter 词干处理器是相对简单的算法，可以应用于信息检索中。（Ref：Ch23）

### 单词和句子的词例还原

词例还原（tokenization）：把文本切分成单词和句子。

- 单词切分（word segmentation）

- 句子切分（sentence segmentation）

#### 中文的自动切词

中文切分算法：最大匹配算法（maximum
matching，maxmatch），是一种贪心搜索算法，作为基准算法，需要配备一部语言的词典（词表）。缺陷在处理未知词或者未知组合时。

### 拼写错误的检查与更正

拼写错误更正的标准算法是概率算法。

拼写错误的检查和更正分解为三大问题：

- 非词错误检查（non-word error detection）：检查会导致非词的拼写错误。

- 孤立词错误更正（isolated-word error correction）：更正会导致非词的拼写错误。

- 依赖于上下文的错误检查和更正（context-dependent error detection and
.  correction）：如果错误的拼写恰好是一个英语中真实存在的单词，就需要使用上下文来检查和更正这样的拼写错误。

有限状态形态剖析器提供了实现大规模词典的技术手段。对于每个单词都可以给出形态剖析，因此 FST 剖析器在本质上就是单词的识别器。如果使用投影操作把 FST 下侧的语言图抽取出来，那么 FST 形态剖析器就可以转化为有效的 FSA 单词识别器。FST 词典就会表示那些能产性的形态变化。

最小编辑距离算法用于计算来源和表层错误之间的距离。

### 最小编辑距离（minimum edit distance）

字符串距离（string
distance）：两个符号串之间的距离是这两个符号串彼此相似程度的度量。

最小编辑距离是符号串距离算法的基础，说明了两个符号串之间对齐的情况。

Levenshtein 距离是加权的最小编辑距离。

最小编辑距离使用动态规划进行计算。

最小编辑距离算法可以用来做两个符号串之间的最小代价对齐（alignment）。

### 人的形态处理方式

完全枚举法（full
listing）：假定人的心理词表中，不管单词内部形态结构如何，只会把语言中的全部单词都一一枚举出来。形态结构只是一种没有因果关系的现象。

最小羡余法（minimum
redundancy）：假定人的心理词表中，只表示那些有组合能力的语素，因此当处理单词中必须把与单词相关的所有语素组成起来。

### 小结

- 形态剖析是发现在词中所包含的连续的语素的过程

- 英语主要使用前缀和后缀来表示屈折形态和派生形态

- 英语的屈折形态比较简单，包括：人称和数的一致关系以及时态标志

- 英语的派生形态比较复杂，包括：前缀和后缀

- 英语的形态顺序规则（可容许的语素的顺序）可以用有限自动机来表示

- 有限状态转录机是能生成输出符号的有限自动机的扩充。FST 的重要运算包括：组合、投影和交运算

- 有限状态形态学和双层形态学是有限状态转录机在形态表示和剖析中的应用

- 转录机的自动编译程序是存在的，并且对于任何简单的重写规则都能够选出一个转录机。词表和拼写规则可以通过组合和交合不同的转录机的方式结合起来

- Porter 算法是词干还原的简单方法，可以帮助词干剥离词缀。没有包含了词表的转录机那么精确，但是可以应用在不需要做精确形态剖析的工作中，例如：信息检索

- 单词的词例还原可以使用简单的正则表达式替换或者使用转录机来实现

- 拼写错误检查通常可以通过发现那些没有在词典中出现的单词的办法来实现；为此可以使用 FST 的词典

- 两个符号串之间的最小编辑距离是把一个符号串编辑为另一个符号串时所需要的最少的操作次数。最小编辑距离可以使用动态规划的方法来计算结果，也可以用来作两个符号串的对齐。

N 元语法
--------

N 元语法模型（N-gram model）是概率模型。

2 元语法（bigram）是包含 2 个单词的序列；

3 元语法（trigram）是包含 3 个单词的序列；

语言模型（Language Models，LM）是单词序列的概率模型。

### 语料库中单词数目的计算

自然语言中统计计算需要依赖于语料库（单数：corpus，复数：corpora）。

语料库是计算机可读的文本或者口语的集合体。

阻断（disfluencies）：切断和有声停顿。

切断（fragment）：一个单词在中间被拦腰切开就形成切断。

有声停顿（filled pauses）：也称为过滤成分（filters）。单词的停顿。

词目（lemma）：具有相同的词干和相同的词义并且主要的词类也相同的词汇形式

词形（wordform）：是一个单词的全部的屈折或者派生形式。

语言的“型”（type）和“例”（token）。“型”就是语料库中不同单词的数目，或者是词汇容量的大小，记为 V；“例”就是使用中的全部单词数目，记为 N。

### 简单的（非平滑的）N 元语法

计算某个单词的概率，只考虑最接近该单词的若干个单词，近似地逼近该单词的历史，这是 N 元语法模型的直觉解释。

一个单词的概率只依赖于它前面单词的概率的这种假设称为马尔可夫假设（Markov
assumption）

使用最大似然估计（Maximum Likelihood Estimation，MLE）估计 N 元语法模型的概率。

从语料库中得到的计数加以归一化（normalize）。

用前面符号串（prefix）的观察频率来除这个特定单词序列的观察频率，就得到 N 元语法概率的估计值，这个比值称为相对频率（relative
frequency）。

### 训练集与测试集

训练集（training set）或者训练语料库（training corpus）：

测试集（test set）或者测试语料库（test corpus）：

保留集（held-out set）

初始的测试集又称为调试测试集，又称为开发集（development test set，devset）。

在一些数据上训练，在另一些数据止测试，还可以用来评估不同 N 元语料的总体结构。

#### N 元语法及其对训练语料库的敏感性

确保训练语料库与测试语料库有相似性。

#### 未知词：开放词汇和封闭词汇

未知词（unknown words），或者表外词（Out Of
Vocabulary，OOV），没有在系统中看到的单词。

在测试集中出现的表外词 OOV 的百分比称为表外词率（OOV rate）。

在封闭词汇（closed vocabulary）系统中，假定不存在未知词。

在开放词汇（open
vocabulary）系统中，给测试集加上一个伪词（pseudo-word）来给这些潜在的未知词建模，这个未知词的模型称为、<UNK\>。

### N 元语法的评测：困惑度

端到端（end-to-end）的评测称为外在评测（extrinsic
evaluation），也称为现实评测（in vivo
evaluation）或者叫体内评测，将语言模型嵌入到某种应用中，并测试这个应用的总体性能。

内在评测（intrinsic
evaluation）：的度量就是一种与任何应用无关的模型质量的评测方法。

困惑度（perplexity，PP）：是对于 N 元语法模型的一种最常见的内在评测的度量指标。困惑度可以用来快速地检验算法，困惑度的改进也可以由端对端的评测来加以确认。

在一个测试集上语言模型的困惑度是该语言模型指派给测试集的概率的函数。

对于测试集，困惑度就是用单词数归一化之后的测试集的概率。

语言的加权平均转移因子（weighted average branching
factor）是语言中的任何一个单词后面可能接续的单词的数目。

### N 元语法的平滑算法

最大似然估计过程的主要问题就是训练 N 元语法的参数，而最大似然估计是建立在特定的训练数据集上，因此会产生数据稀疏（sparse
data）问题。

“平滑”（smoothing）是用来填补零计数的概率导致的概率计算问题。

#### Laplace 平滑

Laplace 平滑（smoothing）或 Laplace 定律（law）：也称为加一平滑（add-one
smoothing）。取语法模型的计数矩阵，先把所有的计数加 1，再对概率进行归一化。在实际应用中，效果不是很好。

#### Good-Turing 打折法

各种打折算法（Good-Turing 打折法，Witten-Bell 打折法，Kneser-Ney 平滑法）都是利用看过一次的事物的计数来帮助估计从来没有看到过的事物的计数。

只出现过一次的单词或者 N 元语法（或者任何事件）都可以称为单元素（singleton），或者称为罕用语（hapax
legomenon），即只出现过一次的单词。

Good-Turing 打折法就是使用单元素的频率作为零计数的一元语法的频率来重新估计概率量的大小。

#### Good-Turing 估计

在对 N 元语法进行打折时，不仅使用 Good-Turing 打折法，还需要使用回退和插值算法。

### N 元语法的插值法

使用“有层次”的 N 元语法的两种途径：

- 回退法（back
.  off）：当高阶语法计数存在零概率值时，就回退到低阶的 N 元语法中，使用非零概率值进行计算。

- 插值法（interpolation）：把所有的 N 元语法估计中的概率值混合起来，即一元语法、二元语法、……、N 元语法的计数进行加权插值。

### N 元语法的回退法

Katz 回退法是使用了 Good-Turing 打折法的回退法。

### 实际问题：工具包和数据格式

回退 N 元语法模型一般用 ARPA 格式存储。

建立语言模型的工具包：

- SRILM 工具包

- Cambridge-CMU 工具包

### 语言模型建模中的高级专题

#### Kneser-Ney 平滑法

Kneser-Ney 平滑法基于绝对折扣（absolute discounting）的打折方法。

Kneser-Ney 打折法使用更加精致的方法分摊回退值，从而提升绝对折扣

Kneser-Ney 算法使用插值的形式比使用回退的形式效果更好。

#### 基于类别的 N 元语法

基于类别的 N 元语法（class-based N-gram）或聚类 N 元语法（cluster
N-gram）是使用单词的类别信息或者聚类信息的 N 元语法的变体。

基于类别的 N 元语法对于处理训练集中的数据稀疏问题效果很好。

IBM 聚类 N 元语法，是一种硬聚类模型；

#### 语言模型的自适应

语言模型的自适应（adaptation）：当某个领域内只有数量很少的训练数据，但是其他领域又存在大量数据时，就会面临语言模型的自适应问题。可以使用领域之外的大量的数据集进行训练，设法使训练得到的模型与某个领域内的小量数据产生自适应。

#### 长距离信息的使用

N 元语法建模中，长距离的上下文信息基本没用。为了更好地利用长距离的上下文信息，可以使用隐藏语言模型（cache
language model）。

跳跃式的 N 元语法（skip N-grams）：上下文可以“跳跃过”某些中间的单词。

可变长的 N 元语法（variable-length N-gram）。

语言模型中结合语言结构的方法参考基于统计剖析的句法结构的语言模型（Ref：Ch14）

基于对话中言语行为的语言模型（Ref：Ch24）

### 信息论背景

困惑度是建立在信息论（information
theory）中关于交叉熵（cross-entropy）概念的基础上。

熵（entropy）是信息量的度量。

- 可以度量在一个特定的语法中的信息量的多少

- 可以度量给定语法和给定语言的匹配程度的大小

- 可以预测一个给定的 N 元语法中下一个单词是什么

计算序列（sequences）的熵。

熵率（entropy rate）：用单词数来除序列的熵所得的值，即每个单词的熵。

平稳（stationary）的随机过程：随着时间的推移，随机过程指派给序列的概率是不变的。

#### 用于比较模型的交叉熵

交叉熵（cross-entropy）。

单词序列 W 上的模型的困惑度形式地定义为交叉熵的指数。

### 英语的熵和熵率均衡性

英语的熵为概率语法试验提供了可靠的下界；英语的熵帮助信息量最大的内容。

计算英语熵值的方法：

- Shannon 计算的是英语中每个字母的熵，熵值偏低；

- 使用随机模型，在很大的语料库上训练模型，使用很长的英语序列指派对数概率

### 小结

- N 元语法概率是一个单词在前面给定的 N – 1 个单词的条件下的条件概率。

  - N 元语法概率可以通过在语料库中简单地计数，并且使之归一化的方法进行计算（最大似然估计 MLE），或者也可以通过更加复杂的算法计算

  - N 元语法的优点是可以使用丰富的词汇知识

  - N 元语法的缺点是对训练语料库的依赖太强

- 平滑算法为 N 元语法概率的估计提供了比最大似然估计更好的解决办法

  - 依赖于低阶 N 元语法计数的常用的 N 元语法的平滑算法是回退法和插值法

- 常用的打折算法

  - Kneser-Ney 打折法

  - Witten-Bell 打折法

  - Good-Turing 打折法

- 评测 N 元语法的语言模型时，要把语料库分为训练集和测试集两个部分

  - 训练集用于训练模型，测试集用于评测模型

  - 测试集上语言模型的困惑度用于对不同的语言模型进行比较

词类标注
--------

词类（Part-of-Speech，POS），又称为单词类别（word
classes）、形态类别（morphological classes）或者词汇标记（lexical tags）。

词类标注（part-of-speech tagging）：把词类指派给单词。

词类标注的常用方法：

- 基于规则的标注（rule-based tagging）：手写规则

- 基于统计机器学习模型的标注

  - 基于 HMM（隐马尔可夫）模型的标注

  - 基于 MEMM（最大熵）模型的标注

- 基于转换的标注（transformation-based
.  tagging）：是基于规则的标注与基于统计机器学习模型的的结合

- 基于记忆的标注（memory-based tagging）

### 英语词的分类

- 封闭类（closed
.  class）：包含的单词成员相对固定的词类，封闭类的单词又称为虚词（function
.  words）。

  - 介词（prepositions）：语义上表示关系。通常是空间或时间的关系。On, under,
. .   over, near, by, at, from, to, with

  - 限定词（determiners）：与名词一起出现，常常作为名词短语开始的标记。a,
. .   an, the

.  - 冠词（article）

. .   - 无定冠词：a, an

. .   - 有定冠词：the（有定性（definiteness）是话语和语义的一个特性）

  - 代词（pronouns）：she, who, I, others

  - 连接词（conjunctions）：用来连接两个短语、分句或者句子。and, but, or,
. .   as, if, when

.  - 并列连接词（coordinating conjunction）：连接地位平等的两个成分

  - 助动词（auxiliary verbs）：can, may, should, are

.  - 系动词（copula）：be, do, have

.  - 情态动词（modal verb）：

  - 小品词（particles）：与动词结合起来一起使用，把意义加以扩展。up, down,
. .   on, off, in, out, at, by

.  - 短语动词（phrasal
. . . . verb）：动词与小品词结合形成一个独立的句法或者语义单位的组合。

  - 数词（numerals）：one, two, three, first, second, third

  - 叹词（interjections）

.  - 否定词（negatives）

.  - 礼貌标志词（politeness markers）

.  - 问候词（greetings）

.  - 表示存在的 there

- 开放类（open class）：包含的单词成员经常变化。

  - 名词（nouns）

.  - 专有名词（proper noun）

.  - 普通名词（common noun）

. .   - 可数名词（count noun）

. .   - 物质名词（mass noun）

  - 动词（verbs）

  - 形容词（adjectives）

  - 副词（adverbs）

.  - 方位副词（directional adverbs）或地点副词（locative
. . . . adverbs）：说明某个行为的方向或地点

.  - 程度副词（degree adverbs）：说明某个动作、过程或性质延伸的程度

.  - 方式副词（manner adverbs）：描述某个行为或者过程的方式

.  - 时间副词（temporal adverbs）：描述某个行为或者事件发生的时间

### 英语的标记集

- Brown 语料库的 87 个标记

- Penn Treebank 的 45 个标记，是小型标记集

- CLAWS 的 C5 标记集，61 个标记，是中型标记集

### 词类标注

词类标注（Part-of-speech tagging，POS
tagging）简称为标注（tagging），给语料中的每一个单词指派一个词类或者其他句法类别标记的过程。

先进行词例还原，才可以完成词类标注，词类标注的困难就是歧义消解（ambiguity
resolve）。

### 基于规则的词类标注算法

词类自动标注算法使用两阶段的体系结构：

- 使用一部词典给每一个单词指派一个潜在的词类表；

- 使用一个手工书写的排歧规则筛选原来的潜在词类表，使每个单词得到一个单独的词类标记。

EngCG 标注算法（EngCG
tagger）是最全面的基于规则的词类标注算法，是使用约束语法的方法。EngCG 中的词典 ENGTWOL 是建立在双层形态学（Ref：Ch3）基础上的

### 基于 HMM 模型的词类标注算法

### 基于转换的词类标注算法

### 评测和错误分析

### 词类标注中的高级专题

### 拼写中的噪声信道模型

### 小结

HMM 与 MEMM
-----------

### 马尔可夫链

### 隐马尔可夫模型（HMM）

### 似然度的计算：向前算法

### 解码：Viterbi 算法

### HMM 的训练：向前——向后算法

### 最大熵模型的背景知识

#### 线性回归

#### 逻辑回归

#### 逻辑回归（分类）

#### 逻辑回归（训练）

### 最大熵模型（MEMM）

### 小结

1. 语音处理

语音学
------

### 言语语音和语音标音法

### 发音语音学

### 单位范畴与发音变异

### 声学语音学和信号

### 语音资源

### 发音音系学与姿态音系学

### 小结

语音合成
--------

### 文本归一化

### 语音分析

### 韵律分析

### 双音子波形合成

### 单元选择（波形）合成

### 评测

语音自动识别
------------

### 语音识别的总体结构

### 隐马尔可夫模型应用于语音识别

### 特征抽取：MFCC 失量

### 声学似然度的计算

### 词典和语言模型

### 搜索与解码

### 嵌入式训练

### 评测：词错误率

### 小结

语音识别：高级专题
------------------

### 多遍解码：N- 最佳表和格

### A\*解码算法（“栈”解码算法）

### 依赖于上下文的声学模型：三音子

### 分辨训练

### 语音变异的建模

### 元数据：边界、标点符号和不流利的现象

### 人的语音识别

### 小结

计算音系学
----------

### 有限状态音系学

### 有限状态音系学：高级专题

#### 元音和谐

#### 模型式形态学

### 计算优先理论

### 音节切分

### 音位规则和形态规则的机器学习

### 小结

1. 句法处理

英语的形式语法
--------------

### 组成性

### 上下文无关语法

### 英语的一些语法规则

### 树库

### 语法等价与范式

### 有限状态语法和上下文无关语法

### 依存语法

### 口语的句法

### 人的语法处理

### 小结

句法剖析
--------

### 剖析就是搜索

### 歧义

### 面对歧义的搜索

### 动态规划剖析算法

#### CKY 剖析

#### Early 算法

#### 线图剖析

### 局部剖析

#### 基于规则的有限状态组块分析

#### 基于机器学习的组块分析

#### 组块分析系统的评测

### 小结

统计剖析
--------

### 概率上下文无关语法（PCFG）

#### PCFG 用于排歧

#### PCFG 用于语言建模

### PCFG 的概率 CKY 剖析

### PCFG 的规则的概率的学习

### PCFG 存在的问题

#### 独立性假设忽略了规则之间的结构依存关系

#### 缺乏对词汇依存关系的敏感性

### PCFG 的改进：使用分离非终极符号

### 概率词汇化的 CFG

#### Collins 剖析器

### 剖析器的评测

### 分辨再排序

### 基于剖析器的语言模型

### 人的剖析

### 小结

特征 与 合一
------------

### 特征结构

### 特征结构的合一

### 语法中的特征结构

#### 一致关系

#### 中心语特征

#### 次范畴化

#### 长距离依存关系

### 合一的实现

#### 合一的数据结构

#### 合一的算法

### 带有合一约束的剖析

#### Early 剖析器结合合一的剖析

#### 基于合一的剖析

### 类型与继承

### 小结

语言和复杂性
------------

### Chomsky 层级

### 正则语言的判定

#### 抽吸引理

### 自然语言是上下文无关的吗？

### 计算复杂性和人的语言处理

### 小结

1. 语义处理 与 语用处理

什么是意义？
------------

意义表示：形式化结构，通过形式化结构捕捉语言语段的意义。

意义表示语言：指定意义表示的语法和语义框架。

语义分析：创建意义表示，并将其指派经语言输入的过程。

四种常见的意义表示：

1. 一阶逻辑

2. 语义网络

3. 概念依存

4. 基于框架

本章的重点：句子字面意义的表示。

### 意义表示的计算要求

- 为什么需要意义？

意义表示能够将句子的意义与现实的世界连接建立起连接关系。

意义表示的最基本要求：即意义表示必须能够用于确定句子意义与我们所知道的世界之间的关系。也就是能够确定意义表示的真实性。

- 意义表示有什么用？

- 意义表示如何处理有歧义的情况？

知识库：

可验证能力：计算机系统需要具备的一种能力，是一种将意义表示所描述的情况与知识库中所建模的世界状态进行比较的能力。

无歧义性：

输入的最终意义表示必须是无歧义的。

模糊性：

规范形式（canonical form）理论：表达同样事情的所有输入应该具有相同的意义表示。

优点：合理地为每个不同提问所蕴涵的命题指派同样的意义，从而保证系统简单。

缺点：使语义分析任务变得更加复杂。

实现：从不同单词的不同用法中选取相同的意义，就可以把同样的意义指派给包括这些单词的短语。

单词具有不同词义，不同单词的某些词义之间具有同义关系。

基于上下文选取正确词义的过程称为词义排歧（word sense
disambiguation），或称为词义标注，与词性标注相似。（Ref：Ch19，Ch20）

句子指派意义（Ref：Ch18）

推理：计算机系统根据输入的意义表示以及存储的背景知识做出可靠结论的能力。

即使一些命题在知识库中没有显式的表示，具有推理能力的系统也能通过基于当前已知命题进行逻辑推导的方式对其真假做出判断。

推理过程中需要具备处理变量的能力，从而满足处理语言输入不确定性提及的需要。

表达能力：一个意义表示框架应该具备足够的表达能力来处理各种广泛的题材，能够充分地表达任何有意义的自然语言语段的意义。（Ref：17.3 节将介绍如何使用一阶逻辑来表达意义）

### 模型论语义学

模型：是一种形式化结构，用于代表世界事件的特定状态。使用特定意义表示语言的表达式能够被系统地映射为该模型的元素。模型能够表示事物、事物的属性以及事物间关系。

意义表示的词汇：

1. 非逻辑词汇（non-logical
.  vocabulary）：是开放的名称集合，代表事物、属性以及关系。在各种（意义表示）方案中基于谓词、结点、链接标记或框架槽标记等形式实现。

2. 逻辑词汇（logical
.  vocabulary）：是封闭集合，包含符号、运算符、量词、链接等。在意义表示语言中，提供了对表达进行组合的形式化手段。

指示（denotation）：非逻辑词汇中的每个元素在模型中的固定且定义明确的对应部分。

解释（interpretation）：一个函数，能够将意义表示中的非逻辑词映射到其在模型中恰当的所指上。

真值条件语义学（truth-conditional
semantics）：意义表示中针对约定连接运算符的处理。以组成部分的意义（基于模型参照）及通过参照真值表得到的运算符意义为依据，确定复杂表达式真值的方法。

模型包括：

域：需要表示的应用或事件状态中的事物的集合。

属性：事物的属性的集合。

关系：事物间的关系就是域元素的有序列表集合或“元组”（tuple）集合，这些列表或元组中的域元素都参与了对应关系。属性和关系的表示方法是一种外延式的方法。

例子：P462 图 17.2

### 一阶逻辑（First-Order Logic，FOL）

一阶逻辑是一种灵活方便、易于理解、可计算处理的知识表示方法。基于模型论语义学，满足可验证性、推理和表达能力的计算基础。

一阶逻辑基础项：

1. 常量：描述世界的特定事物。

2. 函数：相当于英语中用所属格表示的概念。

3. 变量：使系统具备不指向任何特定已经命名的事物的情况下对事物做出判断并进行推断的能力。

基于引用事物的能力、对事物的事实做出论断的能力，能及把事物相互联系的能力，就可以实现初步的组合表示。通过逻辑连词把更大的组合表示结合在一起。

变量的两种用法：引用特定的匿名事物（存在量词）；引用一个集合中的全部事物（全称量词）。

使用存在量词，必须保证至少有一个替换满足句子为真。

使用全称量词，必须保证所有可能的替换都满足句子为真。

λ表示法：提供一种从具体的 FOL 公式进行抽象的方法，特别适合语义分析。扩充了 FOL 句法。

λ化简（λ-reduction）：一种处理方式，通过将λ表达式用于逻辑项时生成新的 FOL 表达式，新的 FOL 表达式中的形参变量可以由指定的项来绑定。

柯里化（currying）：将多论元谓词转换为一系列单论元谓词的技术。

当在分析树中一个谓词的论元并不都作为谓词的子结点出现时，λ符号提供了一种增量式的收集一个谓词论元的方法。

一阶逻辑（FOL）知识库中的各种事物、属性以及关系的意义通过它们与知识库所建模外界世界中的事物、性质和关系之间的对应关系获得。

对于包含逻辑连词的公式，可以把公式中的成分意义与它们所包含的逻辑连词的意义结合起来，从而解释整个公式的意义。

意义表示语言必须支持推理（inference）或推论。也就是给知识库增加可靠的新命题，或者确定没有包含在知识库中的命题的真假的能力。

取式推理（modus
ponens）：FOL 提供的被最广泛实现的推论方法。如果蕴涵规则左手边为真，那么这个规则的右手边也为真。左手边为前提，右手边为结论。（Ref：取式推理的应用在 Ch21）

取式推理的两种典型应用方式：

正向链（forward
chaining）：当一个单独的事实加到知识库中的时候，取式推理用这种事实来激发所有可以应用的蕴涵规则。优点：在需要时，有关事实已经表示在知识库中；缺点：所引用或者存储的事实可能永远不被使用。

反向链（backward
chaining）：取式推理按照相反的方向来证明特定的命题（亦称为查询）。首先，根据查询是否已经存储在知识库中来判定其是否为真；如果不在知识库中，那么就搜索在知识库中有没有可应用的蕴涵规则。

产生式系统（production
system）：在认知模型研究中被大量使用的正向链推理系统，该系统增加了额外的控制知识，用来决定哪些规则需要激发。

常见的推理方法介绍：

正向链：是一种可靠的推理方法。是非完备的推理方法。

反向链：是从查询到已知事实的推理方法。是一种可靠的推理方法，是非完备的推理方法。

向后推理：是从已知结果到未知前提的推理方法。不是一种可靠的推理方法。是一种经常使用、似是而非的推理形式。亦称为诱导法（abduction）或“溯因推理”。

归结法（resolution）：是替换推理技术，是可靠而且完备的。但是计算代价高。

因此，大多数系统还是采用某种链式推理的形式，而把建设系统的主要工作放到用于支持推理的建模知识的开发上。

### 事件与状态的表示

事件和状态的表示构成了语言中所需要捕获的大部分语义信息。

状态是在一定时间段内保持不变的状况或属性；

事件则表示一些事务状态的改变。

事件表示方法：

1. 意义假设（meaning postulates）：存在规模扩展性问题。

2. 同样的谓词：做了太多的假设；缺乏引用问题中特定事件的办法，无法将事件个体化。

3. Davidsonian 事件表示：增加事件变量作为任何事件表示的第一个论元。必须要为每个谓词确定一组固定的语义角色，接着借助额外的谓词捕获其他辅助的事实。

4. Neo-Davidsonian 事件表示：

.  1. 对于一个给定的表层谓词，无须预先确定论元的具体数目，不管在输入中出现多少角色和填充项都可以连接到表层谓词上。

.  2. 只要在输入中提到角色，不需要再对角色进行意义假设。

.  3. 在有密切联系的例子之间，只要使用逻辑连接就可以把它们联系起来，无须意义假设。

#### 时间表示

时序逻辑（temporal logic）：如何用一个有用的形式表示时间信息。

时态逻辑（tense logic）：使用动词时态传达时间信息。（Ref：Ch22
时间表达式的表示与分析）

参照点：用于处理背景中隐藏着另外一个没有命名的事件。在简单时间处理方法中，时间流中的当前时刻等于说话的时间这个当前时刻作为事件发生时的参照点（在之前、在当时、在之后）。参照点的概念是与说话时间和事件时间分开的。

参照方法的时间来表示事件的时间。

#### 体

体（aspect）：涉及相关话题的一个聚类，包括一个事件是否结束，一个事件是否进行，一个事件是发生在一个时间点上还是在一个时间段上，是否世界上的某一个特定状态会由于这个事件的到来而发生。

事件的表示分为 4 个体：

- 静态体（Stative）表示：表示事件的参与者在一个给定时间点具有特定的属性，或者处于一个状态之中。即一个单独的时间点上的世界被捕捉的特定侧面。

- 行动体（Activity）表示：表示参与者所参与的事件，同时该事件没有特定的结束时间点。行动体的行动是发生在时间的某一个片段上。

- 完成体（Accomplishment）表示：描写的事件有一个自然的结束点，并且导致特定的状态。事件是发生在某个时期之内，当期望状态达到的时候，事件就结束了。

- 达成体（Achievement）表示：以一个状态为结束，但是事件是立即发生的。

终结体可能事件（telic
eventualities）：因为完成体表示与达成体表示的结果都导致特定状态，因此可以结合起来作为一类单独的体。

### 描述逻辑

意义表示方法：

- FOL 方法：一阶逻辑方法。（Ref：Sec17.3）

- 语义网络（semantic
.  networks）：事物用图的结点表示，事物之间的关系用有名字的连接边来表示。

- 框架（frames）方法：也称为槽填充（slot-filler）表示法。在基于框架的系统中，事物用特征结构来表示（Ref：Ch15）或者用图来表示。特征叫做槽，槽的值或者填充值可以用原子值来表示，也可以用另一个嵌套的框架来表示。

以上这些方法表示的意义在原则上都可以转换为等价的 FOL 表示。

#### 描述逻辑

描述逻辑是为了更好地理解和说明结构化网络表示的语义，也同时提供了适合于特定类型的领域建模的一种概念框架。描述逻辑是一个方法族，对应 FOL 的一个变化子集。对描述逻辑表达施加的各种限制都为了确保各种重要类型推论的可靠性。使用描述逻辑对某个应用领域进行建模时，着重表达类别、属于类别的个体和个体间的关系这些知识。

构成一个特定应用领域的类别或概念的集合，被称为专业术语（terminology）。

一个知识库中专业术语的部分被称为 TBox；包含关系个体事实的部分被称为 ABox。

专业术语被组织成名为本体知识体系（ontology）的层次结构，用于捕获类别之间包含与被包含的关系。

捕获术语间的层次关系的方法有两种：

- 直接声明类别之间的层次化关系；

- 为概念提供完整的定义，再通过定义来推导层次关系。

描述逻辑中的关系是典型的二元关系，通常被称为角色或角色关系。

#### 逻辑推理

描述逻辑中的重点在于类别、关系以及个体，是逻辑推理的一个受限子集。

逻辑推理系统包括两个紧密耦合的问题：包含的和实例检验，没有使用 FOL 允许的全套推理。

包含（subsumption）：作为推理的一种形式，是基于专门术语中的事实声明两个概念间是否存在子集∕超集关系的一项决策任务。

实例检验（instance
checking）决定一个个体是否是一个特定类别的成员，给定关系这个个体和这个类别的事实。

包含和实例检验隐含的推理机制不仅仅是对专门术语中包含关系的简单检验，而是必须使用专门术语的关系型声明来地推理，以得到适当的包含关系和成员关系。

一个基于基础包含推理的相关推理任务，是在给定专门术语类别事实的条件下获取专门术语的隐含层级结构（impli
hierarchy）。

实例检验是判定一个特定个体是否可以被分到一个特定类别的一项任务。

描述逻辑的主要实现技术是建立在可满足性的基础之上，并且依据于基于模型的语义。（Ref：Sec
17.2）

#### Web 本体语言和语义网络

语义网络：是一种描述网络内部语义的方法。关键部分是对不同应用领域中本体知识的创建与开发。描述逻辑是语义网络开发的一部分。用来表示知识的意义表示语言就是 Web 本体语言（Web
Ontology Language，OWL），其本身包含了一种描述逻辑。

### 意义的具体化 与 情境表示方法

过程性语义模型：

意义即行动（meaning as
action）：话语被看成行动，话语的意义来自于话语导致的行为步骤。

执行图式（executing
schema）模型或 X 图式（x-schema）模型：事件语义的各个部分都是基于感知——行动过程的图式描述的。这个模型通过 Petri 网的概率自动机来表示事件在“体”方面的语义。

通过隐喻表示抽象概念，这些隐喻可以在以感知或行动基元为基础的概念间建立联系。

### 小结

- 形式化的意义表示（formal meaning
.  representation）是计算语言学中意义表示的主要方法，用于捕捉与输入内容（语言）有关的意义。目的是实现语言到世界常识之间的映射。

- 意义表示语言（meaning representation
.  language）是说明意义表示的语法和语义的框架。它的各种变体被广泛地应用于自然语言处理和人工智能。

- 意义表示需要能够支持语义处理的计算要求，包括需要确定命题的真值、支持无歧义的表示（unambiguous
.  representations）、表达变量（variables）、支持推理（inference），以及具有充分的描述力（expressive）。

- 人类语言使用特征来传达意义。表达谓词论元结构的能力是最为重要的特征。

- 一阶逻辑（First-Order
.  Logic，FOL）是一种容易理解的、在计算上可循的意义表示语言。

- 一阶逻辑可以捕获语义表示的重要元素：状态和事件。

- 一阶逻辑可以表达语义网络和框架。

- 现代描述逻辑由完整的一阶逻辑中的子集构成，这个子集满足有用的、计算上可处理的要求。

计算语义学
----------

语义分析（semantic analysis）：将意义表示进行组合并指派给语言表达式的过程。

常用的知识源：词的意义、语法结构所蕴含的常规意义、话语的结构知识、与话题相关的常识以及与话语中事件状态相关的知识。

句法驱动的语义分析（syntax-driven semantic
analysis）：在给句子指派意义表示时，仅仅依赖于词典和语法知识。这个意义表示是独立于上下文并与推理无关的表示。

句法驱动的语义分析的作用：简单的表示足以产生有用的结果；简单的表示可以作为后续处理的输入，进而产生更加丰富和更加完整的意义表示。

句法、词法、复指语歧义和量词辖域都可能引起歧义。

### 句法驱动的语义分析

组合性原则（principle of
compositionality）：句子的意义可以从其组成部分的意义构建而成。

Mad
Hatter 给出的原则提示：句子的意义并不仅仅依赖于句中的词汇量，还依赖于句中词汇的顺序、词汇所形成的群组以及词汇间的关系。即：句子的意义部分依赖于句法结构。

图 18.1 用于语义分析的简单的管道流方法：

输入→句法分析器→（句法结构）→语义分析器→输出的语义表示

规则到规则的假设（rule-to-rule hypothesis）：

### 句法规则的语义扩充

上下文无关语法规则扩充的语义附着（semantic
attachments）。（Ref：Ch15）这些附着是确定如何利用句法结构成分的意义来计算整体意义表示的规则。

使用更加原则性的方法来实例化规则到规则的方法，两种带约束的原则性的方法：

1. FOL 和λ算子符号；

2. 基于特征结构以及统一形式方法。

语法规则的语义附着主要由λ化简组成，其中λ表达式的一个元素用作一个算子，其他元素用作算子的论元。

特征结构和合一运算提供了一种有效的方法来实现句法驱动的语义分析。

### 量词辖域歧义及非确定性

量词辖域问题：包含量化词的表达式也可能引起歧义。

为了解决量词辖域问题的手段：

- 有效创建非确定性表示的能力，该表示需要在不显示枚举所有可能解释的情况下包含它们；

- 从上述表示中生成或抽取所有可能解释的手段；

- 对所有可能的解释进行选择的能力。

#### 存储与检索方法

使用存储替换单独的语义附着。存储包括一个核心的语义表示，以及一个量化表达式的索引列表，这些量化表达式都是从树中该结点的子结点中收集的。

从存储中检索出完全确定的表示所必须的过程。

基于存储的方法存在的两个问题：

只能解决由量化的名词短语引起的辖域歧义问题。

允许枚举给定的表达式所有可能的范围，但是不允许在可能的范围上施加额外的约束。

#### 基于约束的方法

有效地表示非确定性的表述，以及最终表示必须满足的所有约束。

只要一个完全确定的 FOL 表达式与这些约束一致，那么这个表达式就符合要求。

基于约束的非确定性表示方法：

不特定于语法结构或歧义来源。

支配约束赋予表达约束的能力，这些约束可用于排除不必要的解释。

### 基于合一的语义分析方法

将复杂的特征结构与单独的上下文无关语法规则组成对，以此来对诸如数一致关系和次范畴化这样的句法约束进行编码，且这些约束通常无法通过上下文无关语法传递。

### 语义与 Early 分析器的集成

基于 Early 分析器可以把语义结合到语法分析中，

优点：在句法处理时就可以考虑语义，从而在生成意义表示时就可以阻塞语义的非良构形式进入线图。

缺点：耗费精力在孤立成分的语义分析上。

### 成语和组成性

成语（idiomaticc language）：即习惯用语，或者称为“俗语”。

对于习惯用语的结构，最直接的处理方法就是引入为处理这些习惯用语而特意设计的新语法规则。规则将基于语法成分将词项混合，再引入语义内容，而这个语义内容不是从任何词项中得来的。

处理习惯用语的要求：

允许词典项与传统语法成分的混合；

为了能够处理习惯用语多样性的正确范围，允许生成额外的特定习惯用语的成分；

准许在语义附着引入与规则中的任何成分无关的逻辑项和谓词。

### 小结

语义分析是生成意义表示，并将这些意义表示指派给语言输入的过程。

语义分析器能够利用词典和语法中的静态知识，生成上下文无关的字面意义或习惯意义。

组合性原则说明一个句子的意义可以由它的组成部分的意义组合而成。

在句法驱动的语义分析中，部分是指输入的一个句法成分。

通过一些符号扩展，例如：λ表达式和复杂项，可以采用组合方式创建 FOL 公式。

基于特征结构和合一算法提供的机制也可以合成 FOL 公式。

自然语言中的量词会带来一种很难通过组合方式处理的歧义。

非确定性表示可以用来处理由辖域歧义引起的多重解释。

成语（习惯用语）问题无法利用组合性原则解决，但是可以采用设计语法规则及其语义附着技术来处理。

词汇语义学
----------

基于词汇语义学（lexical semantics）建立的词汇语义模型。

词位（lexeme）：表示一个特定形式（正字的或音韵的）及其意义组成的数据对。

词表（lexicon）：由有限个词位组成的表

词目（lemma）或引用形式（citation form）：是用来表示词位的语法形式。

词形（wordforms）：词的具体形式。

词形还原（lemmatization）：从词形到词目的映射过程。

例如：sing, sang, sung 是三个词形，sing 是它们的词目。

词形还原的方法：形态分析算法（Ref：Ch3）

### 词义

词义（word
sense）或含义：是单词特定意义侧面的离散表示，即表示单词意义的词位的一部分。

词的关系：同形关系（homonymy）、多义关系（polysemy）、同形（同音）异义词（homonyms）、同音异义（homophones）、同形异义（homographs）

同形关系：共享同一个发音和拼写的两个含义的关系。

- 含义间的关系是同形关系的一种，含义间的语义关系是系统化的和结构化的。

多义关系：两个含义的语义相关的关系。

- 借喻（metonymy）是多义关系的特定子类型。借喻是使用概念或实体的一个方面来指代这个实体的其他方面和这个实体本身。

同音异义关系：具有相同的发音但是词目拼写不同的两个含义之间的关系。

同形异义关系：同一词目但是发音不同的两个含义之间的关系。

共轭搭配法（zeugma）：通过将相反的含义结合在一起来证明某个词目拥有不同含义的方法。

字典中的词义比计算需要的词义更加细粒度，因此计算需要的词义会将字典中的词义进行分组和聚类。

字典中的词义存在着回环（circularity）问题，但是这些词义依然能够帮助人们理解查询的单词。

为了满足计算的需要，词义的定义方法：

1. 类似于字典中的定义方法，通过目标含义与其他含义间的关系对其进行定义。如：WordNet 中定义的词义关系。

2. 创建一个小规模的有限语义基元组，即意义的原子结构。主要用在定义事件意义时，如：语义角色。

### 含义间的关系

以下关系是含义间的关系，而不是词间关系。

#### 同义关系（synonymy）

同义（synonyms）：两个不同的词（词目）的两个含义相同或者几乎相同。

同义关系：如果两个词在任意一个句子中可以互相替换，并且不影响句子的真值条件，那么这两个词的关系就是同义关系。通常称这两个词有相同的命题意义（propositional
meaning）。

同义词是具有相同或者相似意义的词；反义词是具有相反意义的词。

#### 反义关系（antonymy）

反义（antonyms）：两个不同的词（词目）的两个含义是二元相反值或者位于某个尺度的两个相反的极点上，或者两个含义是完全可逆的，即描述某种反向的改变或者运动。

反义关系：除了相反的意义的某个方面，两个词共享着意义的几乎所有其他方面，因此它们具有非常相似的意义。

#### 上下位关系（hypernymy）

上位词（hypernym，superordinate）与 下位词（hyponym）。

上位词是下位词的抽象，下位词是上位词的具体；

上位词是下位词的超类，下位词是上位词的子类；

上位词表示的类在外延上包含了下位词表示的类。

如果 A 中的所有对象都是 B 的对象，则称 A 蕴涵（entailment）了 B，即含义 A 是含义 B 的下位词。

本体（ontology）是指对单一领域或微世界（microworld）进行分析而获得的不同客体的集合。（Ref：Ch17）

分类体系（taxonomy）是指把本体知识体系中的元素排列成树状分类结构的一种特别方式。

分类体系是上下位关系的子类型。

#### 语义场（semantic field）

部分——整体（part-whole）关系，称为整体部分关系（meronymy），包括：整体词（holonym）和部分词（meronym）。

同义关系、反义关系和上下位关系都是两个含义之间的二元关系。

语义场是一个针对某个特定领域所有词间的关系集合的更加综合、更加整体的模型。使用的工具有：框架、模型、脚本等。

FrameNet（框架网）提供了一个健壮的框架知识的计算资源。在 FrameNet 表示中，框架中的每个词都针对不同的框架定义，并且与框架中的其他词共享意义的各个方面。

### WordNet：词汇关系信息库

同义集（synset，synonym set）：一个义项的一组近乎同义词；

同义集是 WordNet 的重要的基础性成分。

WordNet 将概念表示为可以用来诠释概念的词义列表。

WordNet 中的根结点被称为独立起始概念（unique beginner）。

### 事件参与者

事件论元的两种语义约束：语义角色（semantic roles） 和 选择限制（selectional
restrictions）。

题旨角色：特定的语义角色模型。

#### 题旨角色（Thematic Roles）

深层角色特定于不同的事件。

题旨角色试图捕获不同词之间的语义共性。

参与者的题旨角色就是主题（theme）。

#### 因素交替

题旨角色帮助泛化论元的不同表层实现。

动词支配的题旨角色论元组被称为题旨格（thematic grid）或者θ格或者格框架（case
frame）。

多论元结构的实现被称为动词交替（verb alternations）或者因素交替（diathesis
alternations）。

与格交替（dative alternations）与动词的特定语义类同时出现。

#### 题旨角色存在的问题

基于抽象化具体题旨角色的广义语义角色（generalized semantic roles）。

两种基于语义角色的词汇资源为语义角色标注算法提供训练数据：

1. 命题树库（PropBank）同时使用了原型角色（proto-roles）和动词特定的（verb-specific）语义角色。

2. 框架网络（FrameNet）使用框架特定的（frame-specific）语义角色。

#### 命题树库（The Proposition Bank，PropBank）

PropBank：标注了语义角色的句子的资源库。标记的是宾州树库（Penn
Treebank）中的句子。

PropBank 中语义角色特定于动词；FrameNet 中的语义角色特定于框架。

#### 框架网络（FrameNet）

框架是一个类似于脚本的结构，实例化一组称之为框架元素（frame
elements）的特定于框架的语义角色。每个词唤起一个框架，并且描述及其元素的一些方面。

框架中的语义角色（即框架元素）包括：核心角色（core roles）和非核心角色（non-core
roles）。

FrameNet 还编码了框架和框架元素间的关系。框架间可以彼此继承，不同框架的元素间的泛化关系也可以通过继承获得。框架间的其他关系，例如：因果关系，也同样被表示。

#### 选择限制（selectional restrictions）

语义角色通过论元与谓词之间的关系来表示论元的语义。

选择限制是一种语义类型限制，表示一个动词对允许填充到它的论元角色的概念类别的限制。

使用事件表示来捕获选择限制的语义。

表示语义角色的选择限制的方法是使用 WordNet 的同义集而非逻辑概念。每个谓词指定 WordNet 的一个同义集作为每个论元的选择限制。如果填充语义角色的词是同义集的上位词，那么这个意义表示就是良构的。

### 基元分解

基元分解（primitive decomposition）或者成分分析（componential
analysis）的模型在词义定义中的应用。基元分解可以状态和行为之间或使动与非使动谓词之间的相似性，但是需要依赖于先拥有的大量的谓词。由于难以提出表示所有可能意义的基元集合，所以语义基元在现有的计算机语言学工作中应用不多。

语义特征（semantic features）：表示某种基元意义的符号。

概念依存（Conceptual Dependency，CD）是动词性谓词分解方法。

### 隐喻（metaphor）

隐喻：与借喻（metonymy）类似，即用意义来自完全不同领域的词或短语来提及或探讨另一个领域及其概念。

### 小结

- 词汇语义学（lexical
.  semantics）研究词的意义以及词之间系统化的意义关联的关系。

- 词义（word
.  sense）是词的意义的体现，定义以及关系通常在词义的层面定义，而不在词形层面定义。

- 同形关系（homonymy）是指两个含义共享一个词形但是意义之间没有关联。

- 多义关系（polysemy）是指两个含义共享一个词形并且意义之间有关联。

- 同义关系（synonymy）是指具有相同意义的不同词间的关系。

- 上下位关系（hyponymy）是指具有类别包含（class-inclusion）关系的词间的关系。

- 语义场（semantic field）被用于捕捉某个单独领域的某个词位集之间的语义关系。

- WordNet：是一个大规模的英语词汇信息库。

- 语义角色（semantic
.  roles）从特定深层语义角色出发，通过归纳各类动词之间的相似角色抽象得出。

- 题旨角色（thematic roles）是基于一个有限角色列表的语义角色模型。

  - PropBank：实现了动词特定的语义角色及原型施事（proto-agent）∕原型受事（proto-patient）

  - FrameNet：实现了框架特定的角色列表

- 语义选择限制（selectional
.  restriction）：容许词（特别是谓词）对论元词设置某些语义限制。

- 基元分解（primitive
.  decomposition）是词意义表示的一种方法，基于词元词汇的有限集合。

计算词汇语义学
--------------

语境的相似性可以用于计算语义的相似性。

计算词汇语义学（computational lexical semantics）：词义计算。

1. 词义排歧（word sense
.  disambiguation，WSD）：检查语境中的词例，并决定每个单词在该语境下的义项。

2. 词语相似性（word
.  similarity）计算以及词语之间的关系（上位词、下位词、部分词）。依靠语料相似性以及依靠类似 WordNet 的结构化资源。

3. 语义角色标注（semantic role labeling），也叫格角色指派（case role
.  assignment）或者题旨角色指派（thematic roles
.  assignment）。从句法分析中得到的特征去指派语义角色。

### 词义排歧（WSD）：综述

两种不同的 WSD 任务：

词汇采样（lexical
sample）：一小组预先定好的词语被选择出来，同时每一个词语在特定词典中的目标语义集合也被选择出来。因为词的集合和词义的集合都很小，可以使用监督机器学习算法来处理。先手工标注选出的词语，然后训练分类系统，接着就可以标注没有手工处理的词语。

全词排歧（all-word
disambiguation）：系统输入为整个文本，以及对每个单词都标注了对应词义目录的词典，系统对文本中每一个词都需要排歧。问题是标记集很大，因为数据稀疏问题无法构建大量可用的训练数据，。

### 有监督词义排歧

使用监督学习方法解决词义排歧的问题：从文本中抽取对于预测特定词义有帮助的特征，然后利用这些特征训练一个分类器用来给词语指定一个正确的词义，训练的结果是使用分类器给文本中未标注词语指定词义标签。

对于词汇采样任务，面向单个词语的标注语料库。语料包含目标词语的上下文句子及该目标词语的正确语义标注。

对于全词排歧任务，使用 semantic
concordance 语料，语料中每一个句子中的开放性词语都标注有来自特定字典或者同义词词典的正确语义。

#### 监督学习的特征抽取

监督训练需要抽取对词义具有预测性质的特征。特征向量（feature
vector）由数值构成，编码了语言学信息，是机器学习算法的输入。从邻近的上下文中可以抽取两类特征：搭配特征和词袋特征。词义排歧方法同时使用了搭配特征和词袋特征。

搭配特征（collocational
feature）是指与目标词语有特定位置关系的词语或短语，包含了目标词语左右特定位置的信息。从这些上下文词语中抽取的典型特征包括：单词本身、单词的原形以及该单词的词性。这些特征能够有效地包含局部词汇和语法信息，而这些信息通常能准确地区分给定的词义。

词袋特征（bag-of-words
feature）包含了邻近词语的词袋的信息。词袋是词语的无序集合，忽略了词语的位置信息。采用将目标词语的上下文表示为特征向量。词汇集从训练集中预先选择词语的有用子集。目标词语附近的上下文区域是以目标词语为中心的对称的固定大小的窗口。词袋特征能够有效地捕捉目标词语所在的上下文的一般主题信息，很容易地确定属于特定领域词语的意思。

#### 朴素贝叶斯分类器 和 决策表分类器

相互贝叶斯分类器是基于特征独立假设（朴素地（naively）假设各特征之间相互独立），即给定词义特征之间是条件独立的。使用朴素贝叶斯分类器进行词义排歧时通常利用拉普拉斯平滑方法将概率平滑。

决策表分类器（decision list classifiers）：产生了一系列选择条件。

### WSD 评价：方法、基准线、上限

评价 WSD 这样的组件技术是很复杂的，目标是对 WSD 在端到端应用中的效果评价。

评价嵌入到端到端应用的组件 NLP 任务称为外在评价（extrinsic
evaluation）、基于任务（task-based）的评价、端到端（end-to-end）的评价或体内（in
vivo）评价。

由于外在评价非常困难，并且对应用来说非常耗时，不易推广，因此 WSD 系统通过采用内在评价。内在（intrinsic）评价或体外（in
vitro）评价。将 WSD 组件看成一个独立于任何给定应用的单独系统。系统通过其精确匹配词义准确率（sense
accuracy）来评价，即在测试集中系统标注与人工标注一致的词义所占的百分比。

SENSEVAL 已经对语义评价进行了标准化。提供了共享任务以及该任务的训练和测试语料，并建立了多种语言下的词汇采样和全词排歧任务的语义清单（sense
inventories）。

基准线（baseline）标准、上限（ceiling）标准。

### WSD：字典方法和同义词库方法

使用字典或同义词库的非直接监督方法

#### Lesk 算法

简化的 Lesk 算法：计算词义的字典注释或定义和目标词语邻近词语的次，然后把次最大的词义赋给目标词语。

Corpus
Lesk 算法：不仅仅计算重叠词语的个数，还为每个重叠词语赋予一个权重。权重是逆文档频率（inverse
document frequency，IDF）。

Lesk 算法与监督方法的结合可以通过添加类似 Lesk 词袋特征的方式实现。

#### 选择限制和选择优先度

选择限制（Ref：Ch19）可以作为词义排歧的知识资源。谓词通过排除那些违背其某一选择限制的词义来判断歧义词语的正确意思。由于硬性限制导致合法的句子与选择限制的冲突，因此选择限制常常作为参考条件而不是必要条件。

在词义排歧方面，选择优先性的 Resnik 模型和其他无监督方法一样好，但是不如 Lesk 或有监督方法。

选择优先度（selectional preference
strength）：谓词提供了关于其变量语义类别的大体信息量。可以定义为两个分布之间的信息差异：期望语义类别 P(c) 的分布（直接宾语落入到类别 c 的可能性）和给定特定怕期望语义类别 P(c\|v) 的分布（动词 v 的直接宾主落入到类别 c 的可能性）。这两个分布的差异越大，动词提供关于其宾语的信息就越多。两个分布之间的差异可以用相对熵（relative
entropy）或者 Kullback-Leiber 散度距离来衡量。

特定类和动词的选择关联性（selectional
association）作为该类别对动词一般选择优先度的相对贡献，是一个概率度量，用来度量谓词和支配谓词变元的类别的关联程序。

### 半监督 WSD（最小化监督的 WSD）：自举法

WSD 的有监督方法和基于字典的方法都需要大量的手工构建的资源，有监督方法需要监督训练集，基于字典的方法需要大规模的词典。

自举（bootstrapping）算法，也被称为半监督学习（semi-supervised
learning）或最低限度的监督学习（minimally supervised
learning），只需要非常小的人工标注训练集。

Yarowsky 算法的目标是为特定目标词语建立一个分类器（在词汇采样任务中）。具备是由小的种子集合构造较大训练集的能力。需要一个准确的初始种子集合以及一个好的置信度衡量，从而能够选出好的新例子添加到训练集中。产生初始种子的方法是手工标注一部分实例和启发式地选择正确的种子。

一个搭配一个词义（one sense per
collocation）假设：和目标词义有很强联系的特定词语或短语不可能与其他词义共现。

一段话语一个词义（one sense per
discourse）假设：一个特定词语在一段正文或一篇文章中多次出现，那么通常具有相同的意思。这个假设的有效性依赖于语义的粒度，大部分情况下语义粒度越粗越有效。

### 词语相似度：语义字典方法

词语相似度（word similarity）或语义距离（semantic
distance）度量来代替同义关系。两个词拥有的相同意思特征越多或两个词是近义词，则两个词的相似度就越高或语义距离越近。

度量词语相似度的两种算法：

- 基于语义字典（thesaurus-based）算法：使用类似 WordNet 或 MeSH 的在线语义字典来度量两个义项之间的距离。通常使用上位关系（继承关系）∕下位关系（包含关系）的层次结构。

  - WordNet 算法只能计算名词和名词之间的或动词或动词之间的相似度，而不能计算名词与动词、形容词或其他词性之间的相似度。

- 基于分布（distributional）算法（Ref：Sec20.7）

词语相似度（word similarity）和词语相关度（word relatedness）的差别：

- 词语相似度是指两个词是近义词或在上下文中可以近似替代。

- 词语相关度是指一大类词语之间的潜在关系。

词语相似度是词语相关度的子情况。因此本节中算法统称为相似度度量。

- 在语义字典层次结构图中两个词语或义项之间的路径越短就越相似。基本的路径长度算法的隐含假设是网络中每个链接代表的距离相同。

- 信息量词语相似度（information-content
.  word-similarity）算法仍然依赖于语义字典的结构，但是添加了从语料库中提取出来的概率信息，属于细粒度的衡量。

  - 遵循基本的信息理论

  - 两个概念的最低公共包含结点（lowest common
. .   subsume，LCS）。Resnik 提出利用两个结点的最低公共包含结点的信息量去估计它们共同的信息量

- 基于字典的方法（注释是字典的属性而不是语义字典的属性）：如果字典中两个概念或者义项的注释包含相同的词语，则它们就相似。

基于语义字典的相似度评价（Evaluating Thesaurus-Based Similarity）

- 内在评价方法是计算算法得出的词语相似度分数和人工标注的词语相似度排序的相关序数；

- 外在评价方法是把相似度度量方法嵌入到某些终端应用中。

### 词语相似度：分布方法

分布（distributional）方法直接为 NLP 任务提供词语相关性度量，还可以用来自动生成语义字典（automatic
thesaurus
generation），以及自动地给在线语义字典添加新同义关系和其他关系（如：下位关系、部件关系等）。

一个词语的意思与它周围词语的分布相关（由词之伴可知其意！）

分布相似度度量方法需要确定三个参数：

- 共现的词语；（Ref：Sec20.7.1）

- 词语赋予权重；（Ref：Sec20.7.2）

- 向量距离度量方法。（Ref：Sec20.7.3）

#### 定义词语的共现向量

使用和目标词语具有某种语法关系（grammatical relation）或依存关系（dependency
relation）的词语。

实体的意义以及实体间语法关系的意义，和这些实体相对于其他实体的结合限制相关。

#### 度量与上下文的联系

目标词语和给定特征之间的权重（weights）或关联度（association）。

点间互信息（Pointwise Mutual
Information，PMI）用来度量两个事件的共现频数与假设二者互相独立时它们共现出现的期望频数的比值。

#### 定义两个向量之间的相似度（向量计算）

两个向量之间的距离的度量方法：

- 曼哈顿距离（Manhattan distance），也被称为 Levenshtein 距离，或者 L1 范数。

- 欧几里德距离（Euclidean distance），也被称为 L2 范数。

相似度计算：点乘（dot product）或者内积（inner product）。

向量长度归一化。

Jaccard 度量方法，也称为 Tanimoto 度量方法，或者最小∕最大度量方法。

分布相似度度量方法：KL 散度距离或相对熵。

Jenson-Shannon 散度距离。

#### 评价分布式词语相似度

分布式算法使用内在方式评价：与一个标准的语义字典进行比较。使用 t 检验对关联度进行加权，使用 Dice 或 Jaccard 算法去度量向量相似度。

### 词语关系：下位关系及其他关系

词语语义关系：相似关系、下位关系、上位关系、反义关系、部件关系。

自动学习语义关系利用词汇——句法模式（lexico-syntactic
pattern）。用来推断下位关系的五种模式：图 20.14（P547）

在关系模式挖掘中发现新模式的方法有：

自举法：在大规模语料中具备某种关系的词语能够同时出现在这种关系的多种不同模式中。因此，仅仅需要从一小部分准确的模式去获取具备给定关系的词语集合。然后，这些词语可以用来在大规模语料中查询以某种依赖关系包含这些词语的句子；新的模式可以从这些新的句子中抽取出来。这个过程可以一直重复直到模式集合足够大。使用自举法时需要避免语义漂移。（Ref：Ch22）

大规模的词汇资源（如 WordNet）作为训练信息的来源，每一对上位∕下位关系提供关系中词语的某些信息，然后训练分类器用来寻找具备这种关系的词语。

选择未知词语在一个完整层次结构中的插入位置。

类似命名实体识别的标注任务。使用 WordNet 中的广义分类标签，抽取特征，使感知器分类器。

寻找部分关系（meronyms）很困难，因为表示该关系的词汇——句法模式极具歧义。

学习词语之间的关系是字典归纳（thesaurus
induction）任务的重要组成部分。在字典归纳中，词语间的相似度估计、上下位关系和其他关系被整合起来构造成一个完全的知识本体或者字典。

两阶段字典归纳算法：

自底向上的聚类（clustering）算法，将语义上类似的词语聚集到不带标签的词语层次结构中；

给定不带标签的层次结构，使用基于模式的下位关系分类器去为每一类中的词语指定上位关系标签。

### 语义角色标注

语义角色标注（semantic role labeling），也称为主题角色标注（thematic role
labeling）或者格角色赋值（case role assignment）或者浅层语义分析（shallow
semantic
parsing）：将词语的意义与句子的语义进行链接。目的是自动发现句子中谓语的语义角色。即找出句子中给定谓语的语义变元，为每个变元选择合适的角色。能够改善所有语言理解应用的质量。

主要的语义角色标注方法：基于有监督机器学习，需要大量的训练和测试资源，主要利用 FrameNet 和 PropBank 资源。

语义角色标注都从句法分析开始，通过遍历句法分析的结果来寻找所有的谓语承接语。遍历句法分析树来确定成分与谓语角色的对应，从而将句法成分描述成谓语对应的特征集合，然后利用训练得到的分类器来基于这些特征做出判断。常用特征有：

- 管辖谓语

- 句法成分的短语类型

- 句法成分的中心词

- 句法成分的中心词词性

- 在句法分析树中从成分到谓词之间的路径

- 成分所在人名的时态

- 句法成分和谓词之间的二元线性位置，其值或是前面或是后面

- 谓语的次范畴化

特征按照上面提到的顺序进行排列。

多阶段分类器：剪枝、识别、分类。

语义角色标注需要注意成分重叠问题，因为成分的语义角色是相互依赖的，因此可以采用 N-best 重打分技术。先利用分类器为每个成分指定多个标签，每个标签都有一定的概率，然后再使用全局最优的算法从中挑选最好的标签序列。

利用组块技术可以直接对原始（或者带有词性标注）文本进行语义角色标注。

在评价语义角色标注系统时要求把每个变元正确地指派到相应的词语序列或句法分析成分上。因此可以计算准确率、召回率和 F 值。

一个简单的基于规则的系统可以用来作为基准系统。

### 无监督语义排歧

在语言应用中使用较多的是凝聚式聚类（agglomerative clustering）算法。

评价无监督的词义排歧方法，最好做外在或体内测试。

### 小结

词义排歧（Word-Sense
Disambiguation，WSD）判定特定上下文中词语的正确义项。监督方法利用单个词语（单词任务）或所有词语（全词任务）出现的句子，这些句子使用 WordNet 中的义项进行了标注。监督 WSD 使用朴素贝叶斯分类器、决策列表分类器以及其他分类器进行训练和预测，分类器是在描述词语上下文的词中的搭配特征和词袋特征上进行训练。

WSD 的重要基准系统是选用最频繁词义，等价于 WordNet 中取词语的第一个意义。

Lesk 算法选择字典定义中和目标词语的上下文重叠词语最多的义项作为目标词语的词义。

词语相似度可以通过度量语义字典中的链接距离或者语义字典中的信息含量，使用语料中的分布相似度或者通过使用信息论方法来计算。

分布式相似度的关联度度量方法包括：PMI、Lin 和 t-test。向量相似度的度量方法包括：余弦、Jaccard、Dice 和 Jiang-Conrath。

词汇间的关系（如：下位关系）可以通过词汇——句法模式发现并识别。

语义角色标注通常从对句子进行句法分析开始，然后自动地为句法分析树中的每个结点标识语义角色。

计算话语学
----------

话语（discourse）：由搭配在一起、具有一定结构并且连贯（coherent）的句子群组成的。

话语的类型：

- 独白（monologue）

- 对话（dialogue）

  - 人和人的对话（human-human dialogue）

  - 人机对话（human-computer dialogue）

指代消解（Reference Resolution）：决定代词以及其他名词短语指代的内容。

- 代词回指消解（anaphora resolution）

- 共指消解（coreference resolution）

连贯关系（coherence
relations）：决定话语中句子间的连贯结构。连贯话语中的句子之间必须有语义上的联系。

基于实体的一致性（entity-based
coherence）是一种连贯性，说明连贯的话语与涉及在话语中实体之间必须表现出一定的关系。

话语结构：简单话语分割（discourse segmentation）和连贯性关系（coherence
relation）。

简单话语分割：就是把一篇文档分割成线性序列的多个段落的篇章。

篇章→关系→实体。

### 话语分割

话语分割（discourse segmentation）：把一篇文档切分成一个线性的子主题序列。

使用内聚机制寻找话语结构。

#### 无监督话语分割

线性分割（linear
segmentation）：把文本分割成多个多段单元的任务，其中每个单元表示原谅中的一个子主题或者段落。

内聚性（cohesioin）：是指用一定的语言学手段将文本单元联系或者连接在一起。

词汇内聚性（lexical
cohesion）：是指两个语言单元中基于词语音关系列表现出来的内聚性。

非词汇内聚性：例如，使用回指（anaphora），也称指代或者首语重复。

内聚链：通过相关词语的一个序列表现出来的内聚性。

内聚性（cohesion）与连贯性（coherence）的区别。

- 内聚性：指的是文本单元联系在一起的方式，把两个单元聚成一个单元。

- 连贯性：用来解释不同文本单元的意义如何结合在一起以表达一个更大粒度的话语意义，是两个单元意义之间的关系。

线性话语分割的无监督算法基于内聚性。基于内聚性的分割算法的都是同一个子主题中的句子或者段落之间具有内聚性，而相邻的子主题之间的段落则没有这种内聚性。因此，度量内聚性时希望子主题内部的内聚性强，邻近子主题的内聚性弱。

基于内聚性的算法：TextTilling 有三个部分

- 分词（tokenization）

- 词汇分值确定（lexical score determination）

  - 词汇内聚性得分（lexical cohesion score）

- 边界识别（boundary identification）

  - 深度分数（depth score）

#### 有监督话语分割

基于多种分类器完成有监督话语分割。

特征：无监督分类特征的超集（内聚性特征、词语重叠度、词语的余弦距离、LSA、词汇链、共指等等）

话语标记（discourse markers）或提示词（cue word）：表现话语结构的词语或者短语。

话语标记是领域特定的，可以利用手写规则或者正则表达式去确定特定领域的话语标志。在话语分割的预处理阶段需要进行命名实体识别，

#### 话语分割的评价

WindowDiff 通过在系统输出的分割上滑动一个探测器，即大小为 k 的滑动窗口，来对自动标注的边界和人工标注的边界进行比较。

因为准确率、召回率以及 F 值对分割边界的距离误差不敏感，因此不使用它们来评价分割算法。

### 文本连贯性

连贯关系（coherence relations）：话语的话段之间所有可能的连接

结果（Result）：推测 A 声明的状态或者事件导致了 B 声明的状态或者事件。

说明（Explanation）：推测 B 声明的状态或者事件导致了 A 声明的状态或者事件。

平行（Parallel）：推测 A 声明的和推测 B 声明的都是类似的。

细化（Elaboration）：推测 A 声明和推测 B 声明的是同一个命题。

时机（Occasion）：推测从 A 声明的状态到 B 声明的最终状态的状态变化，或者推测从 B 声明的状态到 A 声明的最初状态的状态变化。

树中每个结点代表一组局部连贯的从句或者句子，称之为话语片断（discourse
segment）。

#### 修辞结构理论

修辞结构理论（Rhetorical Structure
Theory，RST）：是连贯关系理论中的一种，是一种文本组织模型，应用在文本生成领域。包含了 23 种修辞关系，用于表示话语中不同跨度的文本之间的关系。大部分修辞关系保持在两个文本跨度之间，一个作为核心（nucleus），一个作为外围（satellite）。核心是更接近作者意图的并且能够独立解释的单元，外围是离作者意图远些并且通常需要和对应的核心一起解释。

在证据关系（Evidence），外围为核心表述的观点或情况提供证据。

RST 关系：

- 细化（Elaboration）：外围对核心做进一步的补充说明

- 属性（Attribution）：外围给出核心中转述语实例的属性来源

- 对照（Contrast）：多核心关系，两个或多个核心在某些重要的维度上进行对比

- 并列（List）：多核心关系，两个或多个核心不进行比较

- 背景（Background）：外围给出解释核心的上下文

#### 自动连贯指派

连贯关系指派（coherence relation
assignment）：给定一个句子串，自动确定句子之间的连贯关系。

话语分析（discourse parsing）：抽取能够表示整个话语的树或图。

基于提示短语（cue phrases）的浅层算法。

1. 识别文本中的提示短语。

- 提示短语（cue phrase），或者话语标志（discourse marker），或者提示词（cue
.  word）是能够指示话语结构的词或者短语，特别是能够把话语片段联系在一起。

- 连接语（connectives）是一种提示短语，通常是连词或者副词，提供了两个片段之间存在的连贯关系的线索。

1. 基于提示短语把文本分割成话语片断。

- 话语片断的大小是从句或者类似从句的单元。

- 基于单个提示短语手工编写分割规则。

- 利用句法分析器，可以利用句法短语制定更加复杂的分割规则。

1. 利用提示短语对连续话语片段间的关系进行分类。

- 为话语标志撰写规则，但是注意提示短语的歧义性带来的问题

- 使用自举法对大规模语料进行连贯关系自动标注，从而满足训练分类器需要的大量数据。

- 使用正则表达式抽取包围提示短语的话语片段对，然后移除提示短语。最终的句子对不带有提示短语，就可以用于抽取连贯关系的监督训练集。

基于溯因推理（abduction）的算法。

### 指代消解

指代消解（reference resolution）：决定哪些实体被哪些语言表述所指代。

提示语（referring expression）：用于实现指代的自然语言表达。

所指对象（referent）：指向的实体。

共指（corefer）：两个指示语用于指向同样的实体。

先行词（antecedent）：以一种方式准许使用另一个提示语。

复指（anaphora）或者回指：提及一个先前已经被引入话语的实体。使用的指示语是复指语（anaphoric）。

指向实体的方式依赖于实施的话语上下文（discourse
context），还依赖于话语的情境上下文（situational context）。

话语模型（discourse
model）：具有特定地位的信念子集形成了听话人对正在进行的话语的心理模型，包括本话语中所指向实体的表示以及它们参与的关系。

指代消解系统的两个部分：

- 构造话语模型的方法，该模型能够随着所表示的话语的动态变化而演化；

- 各种指示语暗含的信息到听话人的信念集之间的映射方法，包括该话语模型。

话语模型的两个基本操作：

- 当话语中首次提及所指对象时，表示对象被唤起（evoke）而进入模型；

- 当话语中再次提及所指对象时，从模型中访问（access）它的表示。

指代消解的两种任务：

- 代词回指消解（pronominal anaphora
.  resolution）：找出一个代词的先行词，也可以将人称代词消解看成共指消解的子任务。

- 共指消解（coreference
.  resolution）：找出文中所有的指向同一实体的指示词，即找出所有具有共指（corefer）关系的表述。一系列的指示语称为共指链（coreference
.  chain）。

### 指代现象

#### 指示语的五种类型

1. 不定名词短语（indefinite noun
.  phrase）：不定所指将一个新的实体引入了话语环境。

2. 有定名词短语（definite noun phrase）：指示对象可以确认的实体。

.  1. 实体在文本中已经被提起，并且也被表示于话语模型中

.  2. 实体包含在听话人关于世界的信念集中

.  3. 实体本身的描述就包含了唯一性。

3. 代词（Pronoun）：使用代词的所指相比有定名词短语受到更强的约束，要求在话语模型中所指对象具有高度的活力或者显著性。代词指示的实体被引入的位置相比有定名词短语的要近。

.  1. 代词也可以参与提前指代（cataphora），即在代词所指对象出现之前就提及代词。

4. 指示代词（Demonstrative）：即可以单独出现，也可以作为限定词。

.  1. “this”是近端指示词（proximal
. .   demonstrative）：表示文字上或者隐喻上比较接近；

.  2. “that”是远端指示词（distal
. .   demonstrative）：表示文字上或者隐喻上相隔较远（例如：时间上相隔较远）

5. 名字（Names）：包括人名、机构名和地名。在话语中名字可以用来指代新的或者旧的实体。

#### 信息状态

相同的指示语（如许多不定名词短语）能够用来表示新的指示对象，其他的指示语（如许多确定名词短语）可以用来指向旧的所指对象。

信息状态（information status）或信息结构（information
structure）：对不同所指形式提供新的或者旧的信息的方式。

话语中不同各类的所指形式和所指对象的信息度或者显著性之间的关系：

- 约定层级（givenness
.  hierarchy）：表示 6 种信息状态的尺度，每一种信息状态由不同的指示语指示。

- 相关接受度尺度（accessibility scale）：

  - 越显著的所指对象越容易唤醒听者的回忆，因此可用较少语言材料的内容来指代；

  - 不显著的实体需要较长的和较显著的指示语来帮助听者恢复所指对象。

- 听者状态和话语状态来分析信息状态。

  - 听者状态表明所指对象对听者来说是已经知道的或者是新的；

  - 话语状态表明所指对象在话语的前面部分是否已经被提起。

指示语形式和信息状态之间的关系：

- 推理对象（inferrables）：也叫桥接推理（bridging
.  inferences），或者中间物（mediated）。“指示语”不指向文中已经被明显唤起的实体，而是指向与唤起实体具有推理性关系的实体。

- 类属指代（generics）：“指示语”不指向文中已经被明显唤起的实体，而是指向与唤起实体具有同类关系的实体。

- 无所指形式（non-referential forms）：某些无所指形式与指示语在表面上很相似。

### 代词回指消解所使用的特征

给定代词及代词前面的上下文，从上下文中找出代词的先行词。

#### 用来过滤潜在指代对象的特征

4 种相关的固定不变的构词特征：

- 数的一致（number agreement）：指示和和所指对象在数上保持一致。

- 人称一致（perosn agreement）：代词的先行词与代词在数上保持一致。

- 性的一致（gender agreement）：所指对象与指示语的性别保持一致。

- 约束理论限制（binding theory
.  constraints）：指示语和先行名词短语出现在相同句子中，所指关系受到指示语和先行名词短语之间句法关系的约束。

#### 代词解释中的优先关系

用来预测代词指代对象的特征：

- 新近性（recency）：新近的话段所引入的实体比先前较远的话段所引入的实体具有较高的显著性。

- 语法角色（grammatical role）：通过实体表示的语法位置来排序的实体显著性层级。

  - 主语位置的实体的显著性最高

  - 宾主位置的实体的显著性其次

  - 后续位置的实体的显著性最低

- 重复提及（repeated
.  mention）：已经作为焦点的实体，在后面的话语中更可能成为焦点，它们的所指也更可能被代词化。

- 平行（parallelisom）：平行效果会带来明显的优先关系。

- 动词语义（verb
.  semantics）：动词会对某个位置的论元产生强调，而影响指代优先级。

- 选择限制：语义知识可以影响指代优先级。

### 代词回指消解的三种算法

#### 代词回指基准系统：Hobbs 算法

算法最简单，包括：句法分析器、形态性别检查器和数字检查器，常常用作评价的基准系统。

输入：代词所在句子及代词之前的几个句子的句法表示；

#### 代词回指消解的中心算法

中心理论（centering
theory）显式采用话语模型表示。是实体一致的模型。在话语中的任何给定点都有一个单独的实体被作为“中心”，该实体与被唤起的其他实体有所不同。需要句法分析器和形态性别检查器。

#### 代词回指消解的对数线性模型

对数线性分类器：基于手工标注的训练语料，语料由标有先行词的代词组成。

#### 代词回指消解的特征

- 严格的数匹配（strict number）：真或假。

- 相容的数匹配（compatible number）：真或假。

- 严格的性别匹配（strict gender）：真或假。

- 相容的性别匹配（compatible gender）：真或假

- 句子距离（sentence distance）：代词和潜在的先行词之间的句子数目。

- Hobbs 距离（Hobbs
.  distance）：从代词开始回溯找到潜在先行词之前，Hobbs 算法必须跳过的名词组的数目。

- 语法角色（grammatical
.  role）：潜在先行词的角色——句法中的主语、直接宾语或者 PP 中的一个嵌入成分。

- 语言学形式（linguistic
.  form）：潜在先行词的形式——专有名词、确定描述、不定描述或者代词。

### 共指消解

共指消解算法：通过二元分类器，以指代和潜在先行词作为输入，判定是否共指。

共指消解常用特征：

- 回指编辑距离（anaphor edit distance）：从潜在先行词到指代的字符最小编辑距离

- 先行词编辑距离（antecedent edit distance）：从指代到先行词的最小编辑距离

- 别名（alias）：真或假。命名实体标签的多重特征。

- 同位语（appositive）：真或假。指代语和先行词是否处于语法中的同位关系。

- 语言学形式（linguistic
.  form）：潜在回指的形式——专有名称、确定描述、不定描述或者代词。

### 共指消解的评价

模型理论的共指评价（model-theoretic coreference evaluations）

共指链（reference chain）或真实链（true
chain）：是实体出现的正确的或者真实的共指链。

假设链（hypothesis chain）：共指消解算法为实体指派的链或者类。

B-CUBED 算法，评价 MUC-6 方法的扩展，依赖于手工标注的指代短语间的共指语料。计算的是相对于共指链实体在假设链中的准确率和召回率。

### 基于推理的连贯判定

假设分析器能够为每个从句指派合理的语义，那么连贯判定方法就可以依靠和每个连贯关系相关的语义限制来执行。

演绎（deduction）就是依赖这些限制进行推理的方法，是向前推出隐含关系的推理方法，是一种可靠推理形式（即前提为真，结论必为真）。

溯因推理或者诱导（abduction）推理：是后向推理方法，即从结果中寻找可能的原因，是不可靠的推理形式，是可以废止的（defeasible），但是提供了更大范围的推理能力。

比较可选择的溯因推理的证据的质量的方法：

- 概率模型

- 启发式策略：优先选择假设数目最少的解释或者最具体的解释

- 基于代价（cost-based）的策略：结合了概率特征和词性式方法。世界知识和领域知识被用于确定话段间最合理的连贯关系。

注：基于代价的策略可以被应用于语言理解中的许多问题。

### 所指的心理学研究

### 小结

- 与句子一样，话语也具有层级结构。通过假设话语具有简单的线性结构，可以基于词汇内聚性、话语标志或者提示短语对文本进行主题条件分割。

- 话语是连贯的。保持话语连贯的因素是句子间的连贯关系以及基于实体的连贯关系。

- 修辞关系旨连贯关系理论中的一种。用于检测修辞关系的算法可以使用表层提示（例如：提示短语、句法信息）

- 话语模型：为话语状态建立的一种可以演变的话语表示方式，包含：已经提及的实体和实体之间关系的表示。

- 指向实体的方法将世界知识集和话语模型一起加工后传递给听话人。

- 代词所指被用于话语模型中具有足够显著度的所指对象。各种话语的因素都会影响显著性。

- Hobbs 算法、中心算法以及对数线性模型提供了不同的方式来使用和结合不同的限制。

- 完整的 NP 共指任务必须处理名称和确定的 NP。任务中的字符串编辑距离是重要的特征。

- 建立连贯关系的高级算法使用一个或者多个连贯关系构成的限制，能够推出说话者的潜在信息。不完全的逻辑溯因规则可以用来进行此类推理。

1. 自然语言处理的应用

信息抽取
--------

问答 和 摘要
------------

对话 和 会话智能代理
--------------------

机器翻译
--------
