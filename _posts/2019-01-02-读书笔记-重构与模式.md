---
title: "《重构与模式》的读书笔记"
categories:
-   Reading
tags:
-   重构
-   模式
-   笔记
-   方法论
last_modified_at: 2019-01-08
toc: true
toc_label: "文章提纲"
---

### 学习基础

熟悉《设计模式》和《重构》的概念，熟悉基本的 Java 语法和 XML 语法，熟悉 Eclipse 和 JUnit 的使用，有相对较好的英语基础。

    ### 学习过程

1.   先按 P40 的学习顺序读完序号 1~9。理解每个重构模式的动机，尝试读懂示例中的代码 ( 实在不懂就放过，找机会上机也能明白 ) 。
2.   在时间允许的条件下，可以重读和对书中代码重构，从而更加充分地理解重构与模式这两个重要的概念和实践方法。

### 学习目的

使自己编写的代码更容易被人读懂。

### 学习感悟

代码的重构应该是一步步完成的，每次重构的部分不要超过自己的理解能力的 5%。虽然这样操作略显繁琐，但是可以减轻头脑重构过程中的记忆强度，减少代码出错的机会。

代码的重构一定要配合 JUnit ( TDD，测试驱动开发 ) 完成，再加上 Git ( 版本管理 ) 和 Eclipse ( IDE 的重构工具 ) 那就事半功倍了。

## 一、构造函数

### ( 一 ) 、构造函数的重构

6.1. (P43)用 Creation Method 替换构造函数 : 用明确的创建方法代替类中的多个构造函数，避免创建新类时客户无法正确理解和使用构造函数的意图。

优点

-   相比构造函数能够更好地表达所创建的实例的意图；
-   避免了构造函数的局限性，例如 : 两个构造函数不能通过相同的参数和不同的返回类型进行重载；
-   更容易发现无用的创建代码；

缺点

-   非标准化的创建方式，例如 : 不是统一用 new 的方式实例化。

11.1.(P275) 构造函数链 : 把构造函数链接起来，减少代码的重复。特殊的构造函数调用更通用的构造函数，直到全包含构造函数 ( 处理所有的构造函数调用 ) 。

当构造函数数量过多时，可以使用 Creation Method ( 6.1 节 ) 重构。

### ( 二 ) 、Factory 的使用

6.3. (P60)用 Factory 封装类 : 将同一个包里面、实现了相同接口的多个类的实例化交由工厂完成。

优点

-   通过 Creation Method 简化不同种类实例的创建；
-   通过隐藏类减少包结构的“概念重量”；
-   通过共享公共接口实践“面向接口编程，而不要面向实现编程”的理念；

缺点

-   增加新的种类的实例时，必须修改或者增加新的 Creation Method；
-   当客户只能获得 Factory 的二进制代码而不是源代码时，对 Factory 的制定将受到限制。

6.4. (P67)用 Factory Method 引入多态创建 : 将同样的超类，不同的创建过程统一交由工厂完成。

优点

-   有效地表达了对象创建发生的位置，以及如何重写对象的创建；
-   减少因创建自定义对象而产生的重复代码；
-   强制 Factory Method 使用的类必须实现统一的接口；

缺点

-   可能会向 Factory Method 的一些实现者传递不必要的参数。

## 算法重构

### Strategy

7.2.(P102) 用 Strategy 替换条件逻辑

优点

-   通过减少或者去除条件逻辑使算法变得清晰易懂；
-   通过把算法的变体搬移到类层次中简化了类；
-   允许在运行时用一种算法替换另一种算法；

缺点

-   增加设计的复杂度；
-   增加了算法获取数据的复杂度。

### Template Method

8.1. (P166)形成 Template Method : 通过将不同方法中相同的顺序执行步骤提取出来从而实现泛化。

优点

-   通过把不变行为搬移到超类，去除子类中的重复代码；
-   简化并有效地表达了一个通用算法的步骤；
-   允许子类很容易地定制一个算法；

缺点

-   当为了生成算法导致子类必须实现很多方法的时候，就增加了设计的复杂度。

### Composite

XMLBuilder 的例子依据的有(7.5)TagNode，(6.5)TagBuilder，(10.1)TagNode，代码中存在一些小问题，可以试着自己修改。

7.1. (P97)Composed Method ( 组合方法 ) 模式 : 将代码组合成名字简单易懂的方法，再将这些方法组合成更大的方法，从而方便读懂代码。

优点

-   清晰地描述了一个方法所实现的功能以及如何实现；
-   把方法分解成命名良好的、处在细节的同一层面上的行为模块，以此来简化方法；

缺点

-   可能会产生过多的小方法；
-   可能会使调试变得困难，因为程序的逻辑分散在许多小方法中。

7.5. (P143)Composite 模式 : 隐式地构造出树形结构。

优点

-   封装重复的指令，如格式化、添加或删除结点；
-   提供了处理相似逻辑增长的一般性方法；
-   简化了客户代码的构造职责；

缺点

-   构造的隐式的树结构越简单，设计的时候就越复杂。

6.5. (P74)用 Builder 封装 Composite : 因为构造 Composite 有许多重复工作，并且工作流程是复杂而且容易出错的，通过 Builder 来处理构造细节来简化构造过程。

优点

-   简化了构造 Composite 的客户代码；
-   减少了创建 Composite 的重复和易出错的问题；
-   在客户代码和 Composite 之间实现了松耦合；
-   允许对已经封装的 Composite 或复杂的对象创建不同的表示；

缺点

-   接口可能无法清楚地表达其本质意图。

10.1. Collecing Parameter ( 聚集参数 ) 模式 : 是把一个对象传入到不同的方法中，从而在这些方法中收集信息。

经常与 Composed Method 模式一起使用。

优点

-   可以把很大的方法转换成更上的、更简单的方法；

缺点

-   少量地影响结果代码的运行速度。

8.2.(P172) 提取 Composite : 将同一个超类下的多个子类实现的同样的 Composite 提取到超类中。

优点

-   去除重复的类存储逻辑和类处理逻辑；
-   能够有效地表达类处理逻辑的可继承性。

8.3.(P180) 用 Composite 替换一个对象和多个对象的分别 : 用 Composite 实现了既可以处理一个对象，也可以处理多个对象的同样的函数接口。

优点

-   去除了处理一个对象的方法和多个对象的方法中重复的代码；
-   提供了处理一个对象和多个对象的统一函数方法；
-   提供了处理多个对象的更丰富的方法 ( 例如 : OR 表达式 ) ；

缺点

-   可能会在 Composite 的构造过程中要求类型安全的运行时检查。

### Command

7.6.(P155)用 Command 替换条件调度程序 : 为动作创建 Command，将这些 Command 存储在集合中，再通过集合取出对应的 Command 执行。

优点

-   提供了用统一方法执行不同行为的简单机制；
-   允许在运行时改变所处理的请求，以及如何处理请求；
-   仅仅需要很少的代码实现；

缺点

-   会增加设计的复杂度，有时还不如条件调度程序简单。

### Adapter

8.6.(P208)提取 Adapter : 一个类适配了多个版本的组件、类库、API 或其他实体，可以通过提取 Adapter 来统一接口。

优点

-   隔离不同版本的组件、类库或 API 之间的区别；
-   使类只负责适配代码的一个版本；
-   避免了频繁地修改代码；

缺点

-   因为 Adapter 带来的限制，阻止了客户调用 Adapter 没有提供的功能。

8.5. ( P99 ) 通过 Adapter 统一接口 : 使用客户代码与多个类交互时，遵循统一接口完成。

优点

-   客户通过相同的接口与不同的类交互；
-   客户通过公共的接口与多个对象交互；
-   客户与不同的类交互方式相同；

缺点

-   当类的接口可以改变的时候，增加了设计的复杂度。

### Adapter 模式与 Facade 模式的区别

-   Adapter 用来适配对象；
-   Facade 用来适配整个子系统；通常用来与遗留系统进行交互。
-   它们都可以使代码易于使用，但是它们的应用级别不同。

### State

9.1.(P231)用类替换类型代码 : 保护字段从而避免不正确或者不安全的赋值。

采用类替换类型代码而不用枚举，是因为类可以考虑未来行为的扩展，但是现在 Java 的枚举功能更加强大了，所以可以根据自己的习惯来选择。

当重构过程中产生的类需要扩展包含更多行为时，就可以考虑 ( 7.4.State 替换状态改变条件语句 ) 进行重构了。

优点

-   避免非法赋值和比较；

缺点

-   比使用不安全类型需要更多的代码。

7.4. 用 State 替换状态改变条件语句 : 简化复杂的状态转换逻辑

优点

-   减少复杂的状态转换条件逻辑；
-   简化复杂的状态改变逻辑；
-   提供观察状态改变逻辑的角度；

缺点

-   增加设计的复杂度。

9.3. 引入 Null Object : 替换掉 null 的判断逻辑，提供了对 null 的正确处理。

优点

-   不需要重复的 null 逻辑就可以避免 null 错误；
-   通过最小化 null 测试简化了代码；

缺点

-   当系统不太需要 null 测试的时候，会增加设计的复杂度；
-   如果程序员不知道 Null Object 的存在，就会产生多余的 null 测试；
-   使维护变得复杂，拥有超类的 Null Object 必须重写所有新继承到的公共方法。

Singleton
6.6. 将 Singleton 内联化 : 把 Singleton 的功能搬移到需要它的类中，然后删除 Singleton。

优点

-   使对象的协作变得更加明显和明确；
-   保护了单一的实例，而且不需要特别的代码；

缺点

-   当在许多层次间传递对象实例比较困难的时候，增加了设计的复杂度。

9.2. 用 Singleton 限制实例化 : 减少内存的占用，提高运行的速度。

优点

-   改进性能；

缺点

-   变成全局访问；
-   当对象含有不能共享的状态时，重构无法进行。

### Observer

8.4.(P190)用 Observer 替换硬编码的通知

优点

-   使主题及其观察者访问松散耦合；
-   支持一个或多个观察者；

缺点

-   增加设计的复杂度；
-   面对串联通知的时候，会进一步增加设计的复杂度；
-   当观察者没有从主题中删除的时候，会造成内存泄漏。

注 : 例子不熟悉，所以代码没太能领悟

### Decorator

7.3. (P115)将装饰功能搬移到 Decorator

优点

-   将装饰功能从类中搬移去除可以简化类；
-   有效地将类的核心职责与装饰功能区分开；
-   可以去除几个相关类中重复的装饰逻辑；

缺点

-   改变了被装饰对象的对象类型；
-   会使代码变得难以理解与调试；
-   当 Decorator 组合产生负责影响的时候会增加设计的复杂度。

注 : 这部分的代码也不完备，理解起来有困难，建议大致了解作者思路就好了，Decorator 应该是个应用比较广泛的模式，以后自己可以通过实践探索。

### Decorator 与 Strategy 的区别

相同点

-   都可以去除与特殊情况或选择性行为相关联的条件逻辑；
-   都通过把条件逻辑搬移不对劲新的类中达到这一目的；

不同点

-   Decorator 主要把自己包装在一个对象之外
-   Strategy 则用在一个对象之中。

11.2.(P278)统一接口 : 找出所有子类的公共方法，复制到超类中，在超类中执行空行为。

11.3.(P280)提取参数 : 通过客户代码提供的参数对字段进行赋值。

注 : 这两节都是辅助 Decorator 进行重构的。

6.2.(P51)将创建知识搬移到 Factory : 避免创建代码到处蔓延。

优点

-   合并创建逻辑和实例化配置选项；
-   将客户代码与创建逻辑解耦；

缺点

-   如果可以直接实例化，用 Factory 就会增加设计复杂度。

注 : 可能作者认为采用的是 HTMLParser 的原因，所以给出的代码不全，不利于理解重构的含义。

### Visitor

10.2.(P259)将聚集操作搬移到 Visitor : 适用于从多个对象中聚集信息，适用于从不同的对象中聚集信息。使用起来难度较大，首选应该是 Collecting Parameter 方法 ( P253，10.1. ) 。

优点

-   调节多个算法，使其余适用于不同的对象结构；
-   访问相同或不同继承结构中的类；
-   调用不同类上的类型特定方法，无需类型转换；

缺点

-   新的可访问类需要新的接收方法，每个 Visitor 中需要新的访问方法；
-   可能会破坏被访问类的封装性；
-   增加了代码的复杂度。

注

-   尽量使用通用接口把互不相同的类转变成相似的类，而少用 Visitor 模式。
-   Ralph Johnson : 大多时候并不需要 Visitor，有些时候则是必须要用，别无选择。
-   可能作者认为采用的是 HTMLParser 的原因，所以给出的代码不全，不利于理解重构的含义。

8.7.(P217)用 Interpreter 替换隐式语言

优点

-   比隐式语言更好的支持语言元素的组合；
-   不需要新的代码来支持语言元素的新组合；
-   允许行为的运行时配置；

缺点

-   会产生定义语法和修改客户代码的开销；
-   如果语言很复杂，编程工作量较大；
-   如果语言很简单，不需要考虑使用这个模式，否则会增加设计的复杂度。

2019.1.2. 晨，结束阅读。[学习代码下载](https://files.cnblogs.com/files/zhuyx/RefactoringToPatterns.zip)
也可以参考 [GitHub 中的项目](https://github.com/zhuyuanxiang/git-java/tree/master/RefactoringToPatterns)。

注

-   这种读书笔记对他人帮助不大，因为这个只是为了进一步理解作者的意图而进行的工作，通过输入关键点来确认自己是否真正领悟了作者想表达的意思。
-   当输入这些优点与缺点时并没有领悟，然后再通过输入代码来理解作者如何从一段不好的代码重构成一段好代码的，重构的过程中得到了什么、失去了什么，自己未来编写程序中应该如何平衡。

补充 1 : 不要在意输入代码中出现的错误，那是因为代码不完备，许多类或者函数没有提供源代码。只要输入的代码可以排版和使用自动提示工具，就说明代码符合 Java 的语法规范，那么在阅读全书的过程中可以一点点把代码补全，或者根据自己的理解补全 ( 这也是个理解重构和提高编码能力的机会 ) 。

补充 2 : 如果需要下载 HTMLParser，请注意是 1.3 的版本才是作者使用的。但是与 HTMLParser 相关的例子与原代码并不完全相同，而作者并没有在自己的例子中把逻辑构造完整，因此建议跟 HTMLParser 相关的例子还是跳过吧，否则为了调试通过消耗时间太多。 ( 我现在开始渴望直接看《重构》那本书了。 )

代码目录

贷款风险估算程序 ( 6.1，7.2，8.1，11.1 )

HTMLParser ( 6.2，7.3，8.2，10.1，10.2，11.2，11.3 )

对象-关系数据映射 ( 6.3 )

XMLBuilder ( 6.4，6.5，7.5，8.5 )

二十一点游戏 ( 6.6 )

集合类库 ( 7.1 )

SystemPermission ( 7.4，9.1，9.2 )

Product ( 8.3，8.7 )

CatalogApp ( 7.6 )

JUnit ( 8.4 )

数据库查询 ( 8.6 )

Applet ( 9.2 )
