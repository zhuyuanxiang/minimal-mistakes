---
title: "《Head First 设计模式》读书笔记"
excerpt: "将书中重要的内容摘取出来，并对学习过程给予了说明。"
categories:
- Reading
tags:
- 设计模式
- 读后感
- 总结
last_modified_at: 2018-12-21
toc: true
toc_label: "文章提纲"
---

## 阅读指南

精读一章内容，手工输入一章代码 ( 注 1 ) ，与书中描述的思想进行印证，实在搞不懂就放过吧。设计模式绝对不会一次就看懂的。

这本书对于理解设计模式很有帮助，就是例子不太符合中国人的思维模式，但是坚持下去肯定会搞明白的。

## 全书精华

1. Chap12 的 Ducks，通过一点点重构 Ducks 程序，将模式一个个加入其中，帮助对模式的深入理解。

2. Chap12 的 DJView，通过一个完整的 MVC 程序，将 Observer、Strategy、Composite 以及 Adapter 模式用架构层面的设计整合起来，不仅可以更好地理解单个模式，还可以理解 MVC 模式。

## 模式总结

1. Strategy ( 策略模式 ) ：定义一组算法类，用于运行过程中替换算法。
    * 封装变化
    * 多用组合，少用继承
    * 多针对接口编程，少针对实现编程
2. Observer ( 观察者模式 ) ：定义一个主题和一组观察者，可以在主题变化时通知订阅了主题的观察者。
   * Strategy 封装的是函数调用的算法。
   * Observer 封装的是传递数据的内容。
   * 交互对象之间强内聚、松耦合。
3. Decorator ( 装饰模式 ) ：本质不变，外面增加一层层装饰。例如：Stream 的包装。
   * 设计的类，禁止修改，允许扩展。
   * 不采用继承的方式来扩展功能。
4. Factory ( 工厂模式 ) ：所有的工厂都是用来封装创建对象的过程    。
   * Simple Factory ( 简单工厂 ) ：将业务逻辑与对象创建操作分离开。
   * Factory Method ( 工厂方法 ) ：把对象的创建工作委托给子类的工厂方法。
   * Abstract Factory ( 抽象工厂 ) ：把对象的创建工作委托给实现了接口的工厂方法。
     * 依赖于抽象，而不依赖于具体的类。
5. Singleton ( 单例模式 ) ：通过禁止其他对象对自己实例化，而改由自己的静态方法对自己实例化，确保一个类只有一个对象。
6. Command ( 命令模式 ) ：解耦调用者与执行者之间的关系，相互之间的联系通过命令对象完成，调用者只对调用对象的 execute()方法发出请求。
7. 改造已有系统接口，使异构系统也可透明地相互调用。
   * Adapter ( 适配器 ) ：将一个类的接口转换成客户期望的另一个接口。例：数据库连接
   * Facade ( 门面模式 ) ：将一组接口转换成客户期望的单一接口。例：设备驱动程序
   * 最小知识原则：调用其他方法时，涉及的对象越少越好。
     * 对象调用自己的方法
     * 对象调用作为参数传入的对象的方法
     * 对象调用自己的方法创建的对象或实例的方法
       * ( 以上三点强调：不要调用其他方法返回的对象的方法 )
     * 对象调用自身组件的方法
8. Template ( 模板模式 ) ：封装算法，在一个方法中定义一个算法的框架，而将具体的实现委托给子类。框架中调用的方法为钩子，从而超类控制一切，子类实现钩子等待超类调用。
   * 好莱坞原则：别找我，我会去找你。
9. Collections ( 集合 ) ：
   * Iterator ( 迭代器 ) ：遍历集合而无须暴露集合的实现
   * Composite ( 组合模式 ) ：可以将对象的集合和单个对象组合在一起。
   * 类应该只有一个改变的理由。
10. State ( 状态模式 ) ：将状态封闭为对象，将行为封装成方法；新的状态生成新对象，新的行为生成新的方法。
    * 行为不变，状态改变用 State
    * 行为改变，状态不变用 Strategy
11. Proxy ( 代理模式 ) ：采用创建代理对象的方式控制客户端对具体对象的访问。
    * 远程代理管理客户端和远程对象之间的交互；
    * 虚拟代理控制实例化开销大的对象；
    * 保护代理控制客户端对具体对象的访问。
12. Compound ( 复合模式 ) ：MVC-Model，View，Controller
    * Model 与 View 之间使用 Observer 模式。Model 是 Subject，View 是 Observer，当 Model 改变时通知 View 发生改变。View 只从 Model 中获取数据 ( 例如：调用 Model 的 getXXX()方法 ) ，不修改 Model 的数据 ( 例如：不调用 Model 的 SetXXX()方法 ) ，不操作 Model 的行为 ( 例如：不调用 Model 的行为方法 ) 。
    * Controller 与 View 之间是 Strategy 模式。View 只对 Controller 的接口编程，不与具体的 Controller 实现耦合，从而可以面对不同的 Controller 实现不同的行为。
    * View 自身使用 Composite 模式。
    * 还可以使用 Adapter 模式，使已经存在的 Controller 和 View 与 Model 适配。

注：

1. 源代码一定要去下载，书上的代码内容不够

2. 设计模式并不复杂，这 23 种模式的理解之一就是介绍如何针对接口编程

编程思路的演变：针对函数编程→针对对象编程→针对接口编程
